[{"title":"大学那些事","date":"2017-03-18T02:27:40.000Z","path":"2017/03/18/大学那些事/","text":"开头，先放上我最喜欢的BGM，是链接到Youtube的。Youtube，已经被墙了，需要翻墙才能看到。什么？不会翻墙，好吧，真是我国的合格好公民。老哥，那你只能自己想办法，或者选择不看了。毕竟，你不一定喜欢。Background Music Instrumentals - relaxdaily - B-Sides N°1 追梦者 我博客的上一篇文章，同时也是我博客的第一篇文章，被我投稿到了互联网的专题，没想到有幸被收录了。这令我很是高兴，对我来说更是一种激励吧。但令我更没有想到的是，在我着手写这篇文章时，我的上一篇文章已经有100左右的阅读量了。在网络上，有这么多的人看我的文章，这还是第一次。所以，更是给了我，很大的激励作用。不光是阅读量创下了历史记录，评论量也创造了我的历史。其中评论最多的就是鼓励我了，在此，对各位的帮助、鼓励表示由衷的感激。同时，上篇文章还有一人赞赏，这也是我有史以来，得到的第一次赞赏。我同样知道是在鼓励我，真的谢谢。我以前的时候也不怎么写作，所以写的文章难免思维混乱。但，这里是我自己的博客，我可以想写些什么就写些什么吧。 最近，我一直在复习Android基础知识，打算着整理一篇文章出来。但是，自从我写完上次文章以来，我发现我的写作热情一直未退去。总想着写点什么东西。毕竟这里是我的博客，我可以任意的写作。今天，就来说说我自己为何学习Andriod。虽然我还是比较的菜，我的故事显然也不是什么励志的故事。现在人们不都是喜欢看鸡汤文嘛，但我的故事可能就离鸡汤文比较远了，毕竟我现在真的什么也没有。在这里写出来，也是想留给自己以后来看吧。不知道，几年后者几十年后的自己再看到这些会不会有一些不一样的感受呢！ 本人是一名，非985、非211工程的全国二流大学的一名非计算机专业的在校大学生，也就是常说的非科班出身。看到这里，你就会知道了，我的故事也不会是什么励志的，也不是什么所谓的逆袭。这些我显然都不贴边。至于，为什么来到这里学习，完全是误打误撞，有些我自己还没有想明白。但我能知道的就是我来到这里确确实实的是后悔了。首先，先不谈论学校方面，就谈选专业方面，我可能就完全的失败了。现在学的专业，我真的是不怎么喜欢，可以说，也没有什么兴趣。我想，来到这里的大部分人也都如此。我不相信在刚刚经历了高考的一些17、18岁的少年真的想明白了自己想要什么吗？反正我那个时候是不知道自己想要什么的，也不清楚未来该做些什么。就这样，填了高考志愿来到了这个学校。简直就是一个笑话一样，但我也不相信就我一个人会犯这样的笑话。我想在这种考试制度下肯定会有许多人和我有着类似的经历。但是没有办法，要么回去，要么回来。 所以，在我心中一直都有一个心结，那就是我不如退学算了。这种想法一直都在我心中，只是我没有办法和父母说出来。没有任何办法，虽然我向来是向往自由主义的。但是，我的骨子里毕竟还是传统的。虽然，我的父母对我是很开放的。但，毕竟他们的骨子里，还是和今天的中国父母没有什么区别。他们也很看重知识，他们不知道你在学校做了什么，反正，他们知道的就是，你只要在学校就能学到知识。所以，虽然我早就有退学的心思了。但是，对我而言，我是更不想伤害到我的父母的。也许他们会同意我这么做，但并不会是开心的同意。显然，这对他们的伤害更大。所以，我也始终没能开口去说出。其次，我肯定是没有乔布斯、比尔盖茨的才能的，人家的理想是改变世界。最后，也确实是改变了世界。虽然人家退学了，但是人家有才能啊，像我这样的什么也没有，显然就真的是很可悲。有时候，想想我自己，我真的是感觉很可怕。十几年都在读书了，到头一来，可能什么也不会做。这真的是很可悲，可悲到想哭的勇气都没有了，也简直是无法想象的事实。所以，我也不知道我的路在何方。人家都说，路在脚下，可是我连脚下的路都不熟悉，我怎么走向远方呢。我还在一直的困惑，此时已是2016年的3月。 开学后，我还是回到了学校，尽管心里千百般的不情愿。但往往事与愿违也不是自己可以控制的。回到学校的心情自然是不好的，因为自己整天显得无所事事。虽然照常上课，但我通常是不怎么听的。只是做些自己想要做的事情。因为，要我无面对一些不喜欢的事情，我的内心往往是很痛苦的。尽管我不会轻易地说出来，但是有些事情就是这样，自己心里明白这么做的道理就好了。有些事情，你就是不能捅破那层窗户纸的。没有必要去说出来，让别人同情你或者是怎么样的，反正我是不习惯这样的。这也就是我为什么没什么朋友的原因吧。接下来，又是一学期将要过去。心里当然还在想着那个心结，就是我到底要不要继续这么去大学里混日子。偶然的原因在知乎闲逛，就逛到了Android专区。然后，就看到很多前辈自学的经历，很是触动。所以，我就决定看一看自己是不是也能通过自学得到一些什么。于是乎，我便打算开始自学了。 于是，2016年6月开始接触Android。我也总算是找到一些自己喜欢的事情做了。然后，那一整个假期。除了吃饭、睡觉，其余的时间我基本上都在学习Android。我还记得，那一个假期，我哪里都没有去过，整天就是把自己圈在屋子里。之后的3个月左右，我大概将Android基础部分学了一遍。但我知道这还远远不够，因为IT领域的更新速度实在太快了。我看的入门书籍还是基于Android 4.0基础上的，而Google此时早已推出了Android 6.0。新技术也是层出不穷，总之，这一个阶段我走的真是异常的艰难。好在，坚持了下来。2016年9月，我还是又回到了学校，这一次我好像没有以往那么重的包袱了。因为，我觉得我已经找到我感兴趣的事情了。其实，一切都是表象，这里的道路远远没有想象中那么好走。刚开始，还好，我每天都会写一写Android。但是，我越来越发现自己的进步突然间变得好慢。 这时，我的内心其实是急躁的。我不知道该如何度过这一时期，就好像一头横冲直撞的公牛一样没有了方向。加上每天多多少少还要上课，毕竟我不是科班，所以还是耽误我蛮多时间的。然后，我还没有办法彻底的不上课，而且我原本以为晚上的好时光也被上自习代替了。这时的我的内心，真的是五味陈杂，我再一次陷入泥沼。我不知道，这和高中为了应试进行备考有什么差别。难道每天脑子里就该想如何考试，如何拿高分，这就是我上大学的意义吗？那时，我就在想，如果再给我重来一次的机会。我宁愿退学。这种所谓的大学，不读也罢，没有什么好留恋的。所以这一时期，我内心是憔悴的。我不知道该哭还是该笑。在这种制度下，我发现我真的没有存在的价值。也是到现在我才明白了，为什么人家都努力上985院校。不是为了别的，只是为了遇见一些不一样的人，能有一个不一样的环境。毕竟，遇见的人注定会对你有影响的。就像人们当初评价Facebook一样，为什么Facebook会成功，很大程度上是由于它在哈佛学校诞生的。再加上扎克伯格身边的人来自于各个名校，这就更利于Facebook在各个高校的传播。在美国，私立学校是比公立学校好很多的。所以，人家常春藤在校生就有天生的优越感。人家每天在寝室谈论的都是如何改变世界，成为世界的主宰。最后，人家就是改变了世界。 而我们呢？每天就真的像是那种奴隶一样的生活，每天该做些什么、不该做什么都是安排好的。每天都是循规蹈矩，完全的被人家赶着走的感觉。反正这种方式，我显然是受不了的，尤其是我向往那种自由主义的生活。我们每天也只能吹吹牛皮。像我这样的，连吹牛皮都没有人听。不是我不想交朋友，是我不想变得那么功利、自私。其实，人都是自私的，哪里有什么无私。人类在原始社会的野蛮时代，为了活下去就不得不争夺资源。于是就有了各个部落，你要想活下去，就是把自己部落外的人视为敌人。所以，那时的人的脑子里就是仇恨，你必须要下手狠一些，要不然就可能被别人杀。人类从原始文明到现在唯一没有改变的，就是如何毁灭对手。不管是原始社会的部落战争，还是各个朝代的战争，包括现在的商业战争。目的就是如何毁灭对手，活下去。所以，人类从原始社会到现在的基因里就没有无私，反而自私的基因是一直都存在的，就是与生俱来的东西。所以，在现在自私就是对的，你无私在别人看来才是有病，所以大家好像见不到很多无私的人。其实，谁都很自私，只不过有的不表现出来罢了。比如：我们在学校难免不了考试，然后你一考试，就会造成一个尴尬而又普遍的事情，就是它非要给你分出一个三六九等。所以，总是在考试后，有人就会问问这个人，问问那个人，你考了多少分。我对这种事情真的是厌恶到极点，从初中到现在这种事情一直在发生。但是，我还没办法不回答，但是在我心里是不怎么愿意的。我认为，你问分数，无疑就是比一比嘛，或者说叫做分享。但是，我还在处于一个社会主义国家，做什么事情不都讲究个分享精神嘛。毕竟我们要追求的是共产主义。我还是很爱国的，所以，每次有人问我这种问题，我还不能不回答，显得你不是一个国家的人似得。所以，我通常都会回答他，但是我的心里是极度不愿意的。因为，在我心里分数只是一个客观的反应，他也并不代表一切。我们何必要在自己心里分出个三六九等呢！这种事情，我是觉得真的没有一点意义。我这个人最烦的、及其厌恶的就是以成绩来看待一个人，你成绩再好，品德差的一塌糊涂，对不起，我们真的做不了朋友。你成绩再差，但是，你的品德是没有问题的，那这种人就是值得信任的，值得交往的。所以，在大家都喜欢这样做的时候，我一直都不做，而且从初中一直到现在我也没这么做过。我是不是也很自私。所以，你像我这样的又自私又没什么好习惯又不会聊天又不是现在流行语描绘的高富帅。所以，想我这样的没什么朋友好像就不奇怪了。像我这样的，顶多是喝了酒，和自己吹吹牛皮，就这样。 在学校还有一种现象很奇怪，既然扯到这里了，就谈一下吧。比如：下课了，总有人会说道“这节课听明白了吗？我什么都没听懂”。对这种现象，我虽然很无语，但是已经见怪不怪了，毕竟这种事情已经经历了很多次了。所以现在我要分享一段，我关注的公号，也是我在网络上很敬仰的一名老程序员的感悟吧。 如果有人心里有疑问的话，说明不是一个好学生，作为一个好学生，在经历了这么多年的教育以后，还有疑问，说明教育的不太成功。一个成功的教育产品，应该不能有任何思考，如果你有思考，那也不能说出来；如果你又思考又勇敢还要说出来，那最起码不要写出来；即使以上的规则都违反了，又思考，又说又写，最后的底线是不要签名，不要按手印。如果非得作死，不遵守以上所有规则，发生什么事情都不要感到惊讶。以上的规则适用于朝鲜，因为朝鲜是个神奇的国家。 和今天一样，在古代的时候，统治者也需要下层的人傻乎乎的，古代使用的方法是不让你学习，一个字都不认识，别人说啥你就信啥，老老实实种一辈子地，农夫，山泉，有点田，这辈子好好积德，下辈子再说。现在不行了，因为如果你是文盲的话，没法赚更多的钱养活上层阶级，比如说如果你是文盲的话，去血汗工厂都没法干活，说明书也不认识，所以，必须得让这些奴隶掌握一定的知识，但是，掌握知识是很危险的，万一你胡乱读书，一下子开窍了呢？这对统治阶级是个非常大的威胁。这个世界上有两件事情是最难的，一件事是把你的思想装进别人的脑袋，另一件事情是把别人的钱装进你的口袋。现在的统治阶级需要同时完成这两件事情。使用的方法是垄断教育，只能接受一种教育，古代的时候，不认字的人因为不认字，上别人的当，现在的人，因为受了教育，上文字的当。而且，垄断了教育以后，可以批量生产能干活的笨蛋。所以呢，要搞清楚自己是不是上了当，这个是很难的。反正我是搞不清楚，我每天看新闻联播，政府告诉我，只要听他的就不会上当，所以，我觉得我没有上当吧，呵呵。 不知道别人读后，什么想法，反正我读了之后发现：我操，说的太TM的对了。哪里有那么多的疑问，课本上怎么说的你就怎么学就是了。中国的学生好像都是这么一个德行，XXXX是XXXX课本上就是这么说的，这就说明教育还是很成功的。至少一大部分人，不会去质疑课本。在他们心里统治者说的就是对的，课本就是真理。好吧，对于这种人，我也无话可说了。还有，也不要质疑为什么我不能访问Google、Facebook、Twitter…就是不让你访问，你哪里来的那么多的疑问，没事多看看书吧。其实，有时候答案是比问题多的，你就安安心心的待在给你开放的圈子里不是很好嘛。这个圈子里那么多东西还不够你玩的。百度，淘宝，支付宝，QQ，微信，微博…。然后，在你的圈子里你一定会有这种感慨：我们这里非常美好，人民生活非常富足，都已经达到了小康水平，我们这里建设的都是共产主义，哪里是你外边的世界可以相比的，我们这里各种东西，根本不用什么Google，Facebook…我们在圈子里晒娃、晒美食、晒旅行，无比的满足，根本不用与外界联系，我们大天朝可是什么都不缺，我们这里无比的幸福，我们有这些就够了。外面的网站还都是英文的，我们不需要，天天看着新闻联播，多好的生活啊。唉。。。于是，我们什么也不想，做的非常对，人家的目的就是这样的，所以我们这些人的觉悟还是非常的高，让人家很是放心。说到这里，你不要以为我是不爱国的，我非常的爱国，我也没有要黑别人的意思。如果有一天你通过搜索引擎看到了我这篇文章，千万不要喷我或是怎么的。现在的这些网络水军我是非常的怕。首先，我是非常的爱国的，我都已经读了十几年的书了，我的脑袋早就已经被洗的白白的了，不会有什么其他的思想了。其次，我写这些文章主要是给自己看的，自娱自乐，也不是要黑别人，也没有人知道我这个博客地址，如果你不感兴趣，那么就请出门左转，谢谢老哥。 就在我内心极度焦虑的这一阶段，我仿佛又回到了一年前来到这里那种心情。最好的办法，无非就是逃避，可是我又能逃去哪里。这一阶段内心极度厌学，退学的欲望占据了上风。我甚至还想到过，挂科了我就直接退学了，也就解脱了。后来，也不知道是运气好还是差，没有挂科。可是，一切似乎是那么的无助，我又能怎么样，我什么也改变不了。这一段时间，我也拒绝和家里人通话，有那么两个月吧。没敢和家里人通话，因为我怕我的话语引起家人不必要的担心，这也是我一直不想的。甚至，那一天是我父亲的生日，我都没能鼓起勇气去打一个电话。从早晨一直犹豫到晚上。期间，姐姐还微信告诉我，让我打一个电话。所以，在这件事情上我是一直以来都是内疚的。这一阶段直到我回到家里才找到所谓的归属感、安全感。 现在，想一想这一个阶段发生的事情，感觉自己的做法中带着那么几分稚嫩。毕竟，无论如何，也不要自己难为自己，不要自己伤害自己。毕竟，没什么大不了的，改变不了环境，就去做自己喜欢的事情，让自己变得更好。 时间来到了2017年，放假回到家中，抛除了各种杂念，继续Android。又是整整一个假期，我没有出过家门。对于Android方面也总算是有些进步了。这时的我，比以往感觉要好得多。不止在Android方面，而在于对事件的分析不再那么的绝对，而是多了一些理性。我想，这得益于阅读的积累吧。我们这一代人，大部分都是独生子女吧。大部分不想动脑，不想动手，更不想动力。总把自己看的高高在上的样子，其实是什么也不会干。说到这里，突然想起一个人，叫做Huffman。1952年，当时他还在MIT读书，还是个学生。他也不想上课，他就和老师说，我能不能不上课啊，我觉得你这个课我都会了。然后老师说，那行，你不上课，你得给我展示一下你不上课的理由啊。但是，人家Huffman同学觉得老师说得对，就去展示。像我这样的，顶多展示一下，我特别能睡觉，早晨8点的课都不上。后来，这位不想上课的年轻人设计了一个算法，来压缩。老师一看，这堂课你就不用上了，就是满分。因此，这位不想上课的同学，设计的算法，就是Huffman编码，压缩算法中的王牌，影响一直到今天。用今天一名网红，但是我还是觉得他是一名老师嘛。后来出来创办了锤子科技的罗永浩老师的一句名言来说，就是彪悍的人生不需要解释。其实，我也什么不会干。也只能敬仰一下。所以，有些事情，我宁愿不做。你可以说我这种人活的很悲哀，我也是这样看待自己的。就像大学里的一个怪像，每个人都想着，我如何如何考下来一个证书。然后，有了证书好像就能走向人生的羊癫疯，赢取白富美。然后，就不惜一切代价考了一次又一次，根本不懂所谓的原理，就是我死记硬背也把你考下来。所以，当时看到这种现象我真的震惊了，这TM的怎么和大学期末考试似得，这是所谓的国考嘛。所以，我不怎么考证的，我认为这种证书考不考意义也不大了。是在考记忆力嘛，抱歉，我真不能陪你玩。也许，有了这种证书后，会进入所谓的好企业。但是，如果我是企业的老板，我显然不会招收这种毕业生。毕竟，你就没有所谓的快速学习能力。而我认为，一个企业，要的就是你的学习能力，能够快速掌握某项技能。也许你是可以不靠真本事考下来证书，但是我不相信你能不靠真本事就在一个企业站住脚，每个月领那么几千的工资。也许，会可能，毕竟社会主义，每个人都有那么一种说不清楚的优越感，迷之自信。其实，考证，也不过越来越功利化。你去看看有多少培训机构就知道，这都催生出一条产业链了，我天朝的教育实在是强。就像教育一样，显然就是为了钱、利益。就连我们现在的宗教，不也是这样吗？耶稣为什么而死，如果不是他一招釜底抽薪断了希伯来教的财路，创立基督教，自称天使，我想他还不至于被犹大出卖，钉死在十字架上。一切都是为了钱。宗教都如此，何况我们普通人呢？或许，你该笑我，连尝试也不敢尝试，还敢在这里吹牛皮。对啊，我也很嘲笑自己，有些事情只能讲给自己听，所以你是该嘲笑我，我也没有什么好反驳的，我也没办法反驳。也许，我真的不适合活在这个时代。从某些方面来讲，我想我已经脱离了这个时代，在时代边缘垂死挣扎吧。前面提到了阅读，我想说我们这一代人太缺乏阅读了，只是会看课本。确实是中国式的好学生啊，我也不想说什么了。只是想说，我们这一代人的生活完全陷入电子产品中，它太好玩了，以至于我们控制不住自己，所以有时间多做些阅读吧。还有，前一阵子，我在那里看一本书。然后，走过来一个人，看到我在那里，说了一句“看闲书呢？”。对于这种人，我也不想和他多探讨些什么，就是有种对牛弹琴的感觉。在这里，说下我的观点。首先，阅读是为了增加阅历，开阔眼界，增长见识，虽然短时间你感觉没有什么影响。但是，我相信这个东西在于积累。其次，就是思考为什么人家能写出这样的文章，你却不行。能写出一本出，是要具有大局观念，同时还要有很好的逻辑思维。所以，我认为这种能力很重要，是要靠阅读来积累沉淀的。年轻人，不要急躁，放慢脚步，少一些碎片阅读，多一些真正的书本式阅读，增加增加自己的眼界吧。所以，我认为书没有闲与不闲之分，你认为这本书能增长你的见识，你又对这本书感兴趣，那你就去读就好了，这本书就是OK的，这就是一本好书。所以，对于这种人，我是真想一句话“我操你大爷的，你懂什么？”怂回去。当然，这种人，我更多的是不想和他多说一些什么，我感觉根本就不在一个频道上，浪费时间。但是，我是没有这种攻击性人格的，我也不会当面说出这种话，也就自己写出来给自己看。最近，还有一件事情，就是美国要在韩国部署什么萨德系统。然后，我大天朝人民就坐不住了，各种抵制、制裁。好吧，对于这种事情，也不是一次两次了。我大天朝之前就抵制过日本、菲律宾了，害怕你个韩国不成？然后，我们这些吃瓜群众，尤其是记者，坐不住了。新闻啊，这新闻一定要把握好。我想说的是，你有时间能不能去看看书了，是不是应该把自己的本职工作做好啊。但是，我是怕了，只能说，我大天朝威武。其实，我建议在每次抵制行动前，你先手握爪机向天问，你就知道抵制洋货到底有多难了。什么时候，也能像韩国似得把那些在其位不谋其职的官员给弹劾下台啊。如果，有一天真能这样，那我可就佩服到五体投地啊，刮目相看啊。希望在我有生之年能够见到这一幕，所以，我大天朝群众还需要努力啊。 之后，在开学又回到了学校。临行前，母亲对我说“做什么事情都要有始有终”。嗯，我懂得母亲的意思，这句话也一直会留在我的心里的。所以，我想不出意外的话，我还是会把本科读完吧。然后，去做些喜欢的事情。至于，真正做什么，我也不清楚，可能我真的是活的比较失败的人吧。我现在也不清楚，我们来到这个世界到底是为了什么，我们存在的意义又是什么？古代都说，四十不惑，那我就等到不惑之年再回头来看待这个问题吧。如果到了不惑之年，还是搞不清这个问题，只能说明我是彻彻底底活的很失败。 回到学校后，我终于有一种看清的感觉。终于，在放下一切后的那种释怀感。有些东西注定就是这样，你自己的力量微不足道，你什么也改变不了，看清现实，无疑是最完美的解决办法。凡事不要和自己较劲，要去想如何让自己过的更舒服，想做点什么就做点什么。趁着年轻，也要想着怎么疯狂一下。生命很短暂，和地球的年龄相比，不过是几分钟和一年的关系。所以，不要活的那么纠结，对自己好一些。现在，终于每天可以有很长的时间做自己喜欢的事情。虽然，还是有些人、有些事情、有些制度，不愿去面对。但我也再不想去计较什么，因为于我而言，更值得我关注的事情还有很多，我也不必再在类似的问题上去浪费时间。有些事情，注定没有结果，所以把握过程，做些自己喜欢的事情，让自己变得更美好。这才是我当下乃至以后最重要也是最应该去做的事情。 这一个阶段，我自己感觉是变化最大的。尤其是在心理上，对待事情能够理性的分析了，性格因素少一些。以前，可能是性格因素多一些，理性少一些。总之，这一个阶段可能是自我来到这里以后过的为数不多的我很满意的时期。我开始，变的阳光、自信、坦然。每天早晨看到太阳升起，新的一天开始，每一刻都是崭新的。 不知不觉，这篇博客扯得有点多，也就写着写着写了这么长。也基本把我自大学以来这一阶段的生活写出了一个大概，也写出了我一直想要说出的一些话。幸亏我生长在这个言论自由的时代，我才敢写出我内心的一些想法以及对于一些事情的看法。如有写的不当，请见谅，因为这只是我一家之言。所以，在这里感谢党、感谢政府、感谢人民的教导，我才有勇气说出我想说的话。 其实，写博客就是给自己看的。显然，在这个后博客时代，我已经显得格格不入了。但是，我一路走来得到了网络上好多不知名人士的帮助，在这里我想表达我对你们帮助的感谢之情。今天的搜索引擎这么发达，虽然我这个博客域名没有几个人知道，但我相信总会有人会看到的。假如，你也和我有着相似的经历，或者也正迷茫着。然后，读了我这篇博客，你的内心哪怕是有那么一秒钟的触动。或者是，读出了鸡汤文的味道，虽然我这不是鸡汤文。那么，我想我这篇博客就没有白写。其实，现实生活中，我就是那种向往自由主义的人。虽然，在这个现实的社会，会被人嘲笑。但是，我一直认为，自由才是引爆点。拥有自由，才会有创造的灵感，一个社会才会因此进步。我们可以回顾近两百年，人类文明的发展史，你就会发现，其中的每一项重大发现基本上都会有美国人的贡献。我也并不是故意夸大美国，可是这真的就是事实。美国，也是大家所公认的具有自由、民主、法制的国家，所以我们有时候确实应该学习一些美好的文化。所以，我一直都是向往那种自由的环境，尽管别人可能以为我就是一精神病。但是，我还是希望，中国能够引领这一个时代，创造出改变世界的重大发现，这也一直是我向往的。其实，写到这里，接近结尾，我也在纠结要不要发布出去。然后，自由软件、开源文化的精神告诉我：发出去，让其他人看到。虽然，可能只有我自己看到。但是，也就算是对自由、开源文化的一点追求吧。 最后，引用《中国合伙人》（American Dreams In China）的一句话作为结尾，与大家共勉： 如果额头终将刻上皱纹，你只能做到它不刻在你的心上。 皱纹，刻在脸上那是沧桑，刻在心上那是苍老。 后记：2016年的10月我开始在简书写博客，后来因为上面的种种原因，博客一直的断更。而这篇文章是在断更前已经写了一小部分，但是一直没有发布出来。直到前些天，我决定搭建这个博客，打算一直坚持将博客写下去。然后，我就又续写了之后的一大部分。算是自己对这一阶段的认识与总结。现在，我认为写博客是一个好的习惯。因为在现实生活中，人们宁愿相信好听的假话，也不愿意听刺耳的真话。所以，我决定以后尽量的减少说话，尤其是说废话，让人感觉很无聊的废话是浪费时间的。有这些时间，还不如玩玩手机，毕竟现在的人真的是对手机产生了重度依赖。还有，写博客可以练习写作能力以及逻辑思维能力。就像我现在写的这一篇可能就没什么逻辑，我现在正处于想到什么就写什么的阶段，希望以后会有进步。所以，博客以后会坚持写下去，我认为这就是正确的，我也希望我会一直坚持下去。","tags":[{"name":"生活","slug":"生活","permalink":"https://KevinJe.github.io/tags/生活/"},{"name":"随笔","slug":"随笔","permalink":"https://KevinJe.github.io/tags/随笔/"},{"name":"感悟","slug":"感悟","permalink":"https://KevinJe.github.io/tags/感悟/"}]},{"title":"Android之旅2-Android四大组件之BroadcastReceiver篇","date":"2017-03-10T13:20:57.000Z","path":"2017/03/10/Android之旅2-Android四大组件之BroadcastReceiver篇/","text":"今天继续我们的Android之旅，上一篇写了Android四大组件之一的Activity的知识。今天，我们继续来复习Andorid四大组件之一的BroadcastReceiver。 何为BroadcastReceiver呢？其实从字面就可以看出了，就是广播接收者。那这个广播的作用是什么呢？其实Android中的广播机制和现实中的广播没有什么差别。想一想现实中的广播，是不是有通知消息的用途啊。同样，Android中的广播机制也与此是类似的作用。即，通过发送广播通知系统中的某些组件该干什么了。这干什么的逻辑完全在于你自己想实现什么功能。当然，既然可以发送广播，一定也是有接受广播的功能的。 在Android中广播有两种类型，标准广播和有序广播。 标准广播（Normal broadcasts，发送方式：Context.sendBroadacst()），这是一种完全异步执行的广播，广播发出后，没有确定的顺序，广播接收者通常会在同一个时刻接收到这条广播消息。这通常意味着是高效的，但也意味着，在广播发出后是无法进行截断的。 有序广播（Ordered broadcasts，发送方式：Context.sendOrderedBroadcast()）,这是一种同步执行的广播，广播发出后，在同一时刻，只会有一个广播接收者接收到这一条广播。每一个广播接收者都是按顺序进行执行的。所以，前一个广播接收者既可以将这条广播传递出去，也可以完全的截断广播，使下一个广播接收者无法接收到广播。可以在AndroidManifest.xml文件中标签下设置 android:priority属性，来匹配优先级，优先级越高，就越早接收到广播。 在这里要分清楚一点，虽然广播也是通过Intent进行传递的。但是通过Intent发送广播的机制与通过Intent开启另一个Activity的机制是截然不同的。开启的Activity是处于前台并且可以与用户进行交互的。而发送广播是一个后台的操作，用户并不能意识到。 下面来看一下具体的使用方法： ##接收广播##如何接收广播呢？想要接收广播就要用到如何注册广播，并且在注册的逻辑中添加想要监听的广播就可以了。 广播的注册方式有两种，是四大组件中最为特殊的一个。其余的三个组件都必须在AndroidManifest.xml文件中进行注册声明，而BroadcastReceiver既可以在AndroidManifest.xml文件中静态注册，也可以通过代码进行动态的注册。 静态注册 12345&lt;receiver android:name=\"com.example.kevin.receiver.BootReceiver\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.BOOT_COMPLETED\"/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 在AndroidManifest.xml中的注册BroadcastReceiver与注册Activity没有什么太大的区别，只是标签为。android:name来指定具体的是注册的哪一个广播。在 中声明具体想要接收的广播。这里接收的是手机boot加载完成，也就是监听开机这一动作。在Android中，开机时，系统就会发送android.intent.action.BOOT_COMPLETED这条广播。 然后在代码中可以像下面这样写：123456public class BootReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; Toast.makeText(context,\"Boot加载成功\", Toast.LENGTH_LONG).show();&#125;&#125; 新建一个广播继承自BroadcastReceiver，然后重写其onReceive()方法，只要系统接收到了相应的广播就会执行onReceive()方法。这里只是打印了一句吐司。 动态注册 动态注册就要用到registerReceiver(BroadcastReceiver, IntentFilter)这一方法了。可以看到第一个参数就是一个BroadcastReceiver。第二个参数应该也是见过的，在AndroidManifest.xml文件中用来约束具体要监听哪一个广播，同样在这里也是一样的作用。 12345678910111213141516171819202122232425262728293031public class MainActivity extends Activity &#123; private IntentFilter intentFilter; private NetworkChangeReceiver networkChangeReceiver; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); intentFilter = new IntentFilter(); //当网络状态改变时，系统会发出下面这条广播 intentFilter.addAction(\"android.net.conn.CONNECTIVITY_CHANGE\"); networkChangeReceiver = new NetworkChangeReceiver(); registerReceiver(networkChangeReceiver, intentFilter); &#125; class NetworkChangeReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; Toast.makeText(context, \"网络状态改变了\", Toast.LENGTH_SHORT).show(); &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); if (networkChangeReceiver != null) &#123; unregisterReceiver(networkChangeReceiver); &#125; &#125;&#125; 以上就是动态的注册了广播接收者来监听网络状态的改变。现在可以通过手动的改变网络状态，可以发现吐司确实是可以弹出来的，这就是动态注册。最后，记得在onDestroy()中调用unregisterReceiver()方法来取消注册。 ##发送广播##既然我们已经知道了广播分为标准广播和有序广播，那么它们是如何来进行广播的发送的呢？ 发送标准广播 1234567891011121314@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Button button = (Button) findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(); intent.setAction(\"com.coustom.BroadcastReceiver\"); //发送标准广播 sendBroadcast(intent); &#125; &#125;); &#125; 这里就是点击一下按钮就发送一条com.coustom.BroadcastReceiver这样的广播了，当然既然是通过Intent进行发送广播的操作，就可以用Intent的putExtra()方法来携带一些数据。 下面再演示一下如何通过静态注册和动态注册来接收上面自定义的广播。1.静态注册 在清单文件中注册 12345&lt;receiver android:name=\".MyBroadcastReceiver\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"com.coustom.BroadcastReceiver\"/&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 重写对应的onReceive()方法 1234567class MyBroadcastReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; Toast.makeText(context, \"收到了自定义的广播\", Toast.LENGTH_SHORT).show(); &#125; &#125; 2.动态注册 123456789101112131415@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); IntentFilter intentFilter = new IntentFilter(); intentFilter.addAction(\"com.custom.BroadcastReceiver\"); MyBroadcastReceiver myBroadcastReceiver = new MyBroadcastReceiver(); registerReceiver(myBroadcastReceiver,intentFilter); &#125; class MyBroadcastReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; Toast.makeText(context, \"收到了自定义的广播\", Toast.LENGTH_SHORT).show(); &#125; &#125; 就是通过IntentFilter的addAction()方法来监听指定的广播，然后用 registerReceiver()就可以实现动态的注册广播。 发送有序广播 1234567891011121314@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Button button = (Button) findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(); intent.setAction(\"com.coustom.BroadcastReceiver\"); //发送有序广播 sendOrderedBroadcast(intent,null); &#125; &#125;); &#125; 和标准广播最大的不同就是调用了sendOrderedBroadcast()来发送有序广播，第一个参数仍然是Intent，第二个参数与权限有关，传入null就可以了。接收这广播的方法和上面的相同。 12345 &lt;receiver android:name=\".MyBroadcastReceiver\"&gt; &lt;intent-filter android:priority=\"100\" &gt; &lt;action android:name=\"com.coustom.BroadcastReceiver\"/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 只是这里多了android:priority=”100”，来设置接收广播的优先级。如果你有创建了另一个BroadcastReceiver，并且设置它的android:priority=”50”。那么，MyBroadcastReceiver就会先接收到广播。并且既然MyBroadcastReceiver可以先接收到广播，那么它就可以决定是否将广播继续传播下去。如下所示，就表示MyBroadcastReceiver调用了 abortBroadcast()，表示不想让广播继续传播。于是，其他优先级低的广播就都接受不到这条广播了。123456789class MyBroadcastReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; Toast.makeText(context, \"收到了自定义的广播\", Toast.LENGTH_SHORT).show(); //终止广播的传递 abortBroadcast(); &#125; &#125; ##本地广播## 前面的广播，不论是标准的还是有序的，都面临一个问题。即：我们发出的广播，任何其他的程序都能接收到，我们也可以接收来自其他程序的广播。这样就会带来一些安全上的问题，所以Android中还提供了LocalBroadcastManager来对广播进行管理，也就是本地广播。通过LocalBroadcastManager发送的广播只能在应用程序内部传递，也只能接受程序内部发出的广播。下面来看一下具体的用法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class MainActivity extends Activity &#123; private LocalBroadcastManager localBroadcastManager; private LocalBroadcastReceiver localBroadcastReceiver; private Context mContext; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mContext = this; //得到本地广播管理者 localBroadcastManager = LocalBroadcastManager.getInstance(mContext); Button button = (Button) findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(); intent.setAction(\"com.coustom.LocalBroadcastReceiver\"); //利用本地广播管理者发送本地广播 localBroadcastManager.sendBroadcast(intent); &#125; &#125;); IntentFilter intentFilter = new IntentFilter(); intentFilter.addAction(\"com.coustom.LocalBroadcastReceiver\"); localBroadcastReceiver = new LocalBroadcastReceiver(); //利用本地广播管理者注册本地广播 localBroadcastManager.registerReceiver(localBroadcastReceiver, intentFilter); &#125; class LocalBroadcastReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; Toast.makeText(context, \"收到了本地的自定义的广播\", Toast.LENGTH_SHORT).show(); abortBroadcast(); &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); if (localBroadcastManager != null) &#123; //利用本地广播管理者取消注册本地广播 localBroadcastManager.unregisterReceiver(localBroadcastReceiver); &#125; &#125;&#125; 可以看到通过localBroadcastManager = LocalBroadcastManager.getInstance(mContext);获取到了本地广播管理者的实例。之后的发送广播、注册广播、取消注册广播都是通过localBroadcastManager来进行的。这也就是本地广播与普通广播不同的地方。 以下是官方文档在最后给出的，我的理解还不到位，但还是写出来吧。 ##BroadcastReceiver的生命周期## 一个BroadcastReceiver存在的时期就是在调用onReceive()方法所持续的时间。一旦这个方法返回了，系统就会认为对象已经执行接受，不再活跃了。这对于你在onReceive()中可以执行什么有很大的影响。异步操作在这里执行是不可能的，因为你必须从这个方法中返回并且处理异步操作，但是这时BroadcastReceiver已经不再活跃，它的进程可能再异步操作完成之前被系统杀死。 ##进程的生命周期## 一个在执行BroadcastReceiver的方法的进程（也就是在执行其onReceive()方法）被考虑是一种前台的进程，它会在系统中持续的运行除非在系统内存极紧张的情况下才会考虑杀死它。一旦onReceive()这个方法返回了，BroadcastReceiver就不再活跃了。它的宿主的进程此时对于其他正在运行的组件是重要的。这里尤为重要，如果那个进程仅仅维系一个BroadcastReceiver（一个普遍的例子：对于一个应用用户可能从没或者最近没有与之交互），一旦onReceive()这个方法执行完了，系统就会考虑这个进程是空的，就会主动的杀死它。提供可用的资源给其他更重要的进程。 官方文档最后还给出了一条建议： This means that for longer-running operations you will often use a Service in conjunction with a BroadcastReceiver to keep the containing process active for the entire time of your operation.对于长时间运行的操作，你可以将BroadcastReceiver和Service同时应用，来保证进程在整个你的操作时期都保持活跃状态。这里的建议好像就类似于桌面的小部件的实现方法，就是AppWidget。 ##写在最后##上面提到了Service，它也是Android四大组件的一种，关于与Service有关的知识我们以后再来复习吧。BroadcastReceiver也就先说这么多吧，其中的部分理解还是不够深刻，我们今天就到这里了。","tags":[{"name":"Android","slug":"Android","permalink":"https://KevinJe.github.io/tags/Android/"},{"name":"BroadcastReceiver","slug":"BroadcastReceiver","permalink":"https://KevinJe.github.io/tags/BroadcastReceiver/"}]},{"title":"Android之旅1-Android四大组件之Activity篇","date":"2017-03-10T13:18:14.000Z","path":"2017/03/10/Android之旅1-Android四大组件之Activity篇/","text":"关于为什么要写属于自己的博客，我在前一篇文章中也提到了。主要是归纳自己这一个时期所学到的知识，帮助自己更好的理解，同时一旦忘了某一处，还可以有个地方快速的查到。我也打算在写这些博客期间，将官方文档回顾一遍。然后，还有自己的Java方面也会一起回顾一遍，毕竟自己的Java功底薄弱啊。虽然，我的英文水平很渣，但我相信我会坚持下去的。总之，写博客是一种好的习惯，希望自己可以一直坚持下去。 本篇作为Android的开篇，自然就会写最常见的组件Activity了。 一.Activity的基本使用 1. 创建Activity 2. 开启一个Activity 二.Activity间的数据传递过程 1. 向下一个Activity传递数据 2. 返回数据给上一个Activity 三.Activity的生命周期 1. Activity的生命周期的回调方法以及回调过程 2. 保存Activity的状态 四.Activity的启动模式 什么是Activity，你可以翻译成活动，但我总觉得这么翻译有些不妥，还是不能翻译出官方的味道。有的翻译成视图，这种感觉还会好一些。那么还是让我们看一下官方文档关于Activity的描述： #####Activity##### An Activity is an application component that provides a screen with which users can interact in order to do something, such as dial the phone, take a photo, send an email, or view a map. Each activity is given a window in which to draw its user interface. The window typically fills the screen, but may be smaller than the screen and float on top of other windows. 一个Activity是一个应用组件，它提供了一块屏幕，方便与用户之间进行某些交互。像，打电话，拍照，发送邮件，或者是浏览地图。每一个Activity被给予一块窗口，去绘制它自己的用户界面。这个窗口可以填满整个屏幕，但是也可以是比屏幕更小或者悬浮在其他窗口之上。上面的官方文档的介绍已经很清楚明了了，下面看一下如何使用Activity。 ##创建Activity## To create an activity, you must create a subclass of Activity(or an existing subclass of it). In your subclass, you need to implement callback methods that the system calls when the activity transitions between various states of its lifecycle, such as when the activity is being created, stopped, resumed, or destroyed. 首先要新建一个Activity。并且继承Activity，实现其中需要的回调方法，其中最重要的两个回调方法是onCreate()和onPause()。 onCreate()You must implement this method. The system calls this when creating your activity. Within your implementation, you should initialize the essential components of your activity. Most importantly, this is where you must callsetContentView() to define the layout for the activity’s user interface. onCretate()是一个必须要实现的方法，系统在创建你的Activity时回调这个方法。在这里你可以初始化你的Activity所必需的组件。最重要的是，你需要调用setContentView()方法，来规范用户交互界面。 onPause()The system calls this method as the first indication that the user is leaving your activity (though it does not always mean the activity is being destroyed). This is usually where you should commit any changes that should be persisted beyond the current user session (because the user might not come back). onPause()是在用户首次离开你的Activity时调用的。所以在这个方法中，你应该保留用户的数据，给用户一个好的交互体验。 ###实现UI界面###完成用户界面的绘制，通常最常用的方式就是在一个xml文件中定义好Activity所需要的布局，然后在Activity的onCreate()方法中使用setContentView()方法就可以让一个布局与Activity关联起来。 ###在清单文件中进行声明###每一个Activity都应该在manifest文件中定义，也就是只有在这个清单文件中有过定义，系统才会识别出你是一个Activity。下面是具体需要在什么地方定义的结点。。这句话就声明ExampleActivity是一个Activity，前面的点.代表省略的包名。 1234567&lt;manifest ... &gt; &lt;application ... &gt; &lt;activity android:name=\".ExampleActivity\" /&gt; ... &lt;/application ... &gt; ...&lt;/manifest &gt; ####使用 intent filters####使用下面的intent-filter声明一个当前的Activity是一个主活动，当启动应用时首先加载的页面就是当前这个Activity。 123456 &lt;activity android:name=\".ExampleActivity\" android:icon=\"@drawable/app_icon\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 总结一下如何使用Activity： 新建一个Activity并且继承Activity。 实现其中想实现的回调方法。共有七种回调方法，分别是：onCreate()、onRestart()、onStart() 、onResume()、onPause()、onStop()、onDestory()。 使用setContentView()方法将你的布局与Activity之间进行绑定。而布局一般都是以xml文件的形式进行定义的。这里也就涉及到了Android中的控件。 在manifest文件中进行注册，Android四大组件都必须在清单文件中进行注册，同时BroadcastReceiver也支持动态注册。 ##开启一个Activity##上面讲到了如何使用Activity，但是仅仅有一个Activity是不是也太单调了。而我们现在市面上的应用都是有好多个Activity所组成。所以这里就要用到Activity之间的跳转。而Activity之间的跳转就要用到上面提到过的Intent了。 官方文档中关于Intent的解释为： You can start another activity by calling startActivity(), passing it an Intent that describes the activity you want to start. The intent specifies either the exact activity you want to start or describes the type of action you want to perform (and the system selects the appropriate activity for you, which can even be from a different application). An intent can also carry small amounts of data to be used by the activity that is started. 你可以启动一个其他的activity通过调用, 并传递一个Intent，它用于描述Activity。 intent指定了你想要启动的Activity,或者指定了你想展现的动作（系统帮你选择合适的Activity，它可能来自于其他的程序）。 intent也可以携带比较小量的数据，用于启动Activity。 从上面可以看出Intent分为两种类型，即显式Intent和隐式Intent。 显式Intent：在你自己的应用中，你经常会简单地启动一个已知的Activity, 通过创建一个明确的intent。这个intent指定了Activity的类名。如下为启动一个名为SignInActivity的Activity： 12Intent intent = new Intent(this, SignInActivity.class);startActivity(intent); 隐式Intent：当你的应用中没有相应的功能时，你就可以通过隐式Intent来调用系统的或者是设备上其他的应用来完成相应的功能。类似的如：发送邮件，发送短信，拨打电话。如下为调用手机中具有浏览网页功能的应用访问一个网页： 123Intent intent = new Intent(Intent.ACTION_VIEW);intent.setData(Uri.parse(\"http://www.google.com\"));startActivity(intent); 这就是隐式Intent最有价值的地方，你可以创建一个Intent来描述你想要做什么，系统会为你从其他的应用中选择合适的Activity来处理。 ###Activity间进行数据传递###向下一个Activity传递数据Intent中提供了的一系列的putExtra()方法的重载，可以把我们想要传递的数据暂存在Intent中，启动另外一个Activity后，再从Intent中取出数据就可以了。 Intent一系列的putExtra()方法 比如在FirstActivity中将一个字符串传递到SecondActivity中，可以如下操作： 1.在FirstActivity中将数据保存在Intent中。1234String data=\"Hello SecondActivity\";Intent intent = new Intent(FirstActivity.this,SecondActivity.class);intent.putExtra(\"extra_data\",data);startActivity(intent); 2.在SecondActivity中取出Intent中的数据，getIntent()方法。123Intent intent = getIntent();String data = intent.getStringExtra(\"extra_data\");Log.d(\"SecondActivity\", data); 如果在上一个Activity传递过来的是字符串，在下一个Activity中取出时就应该用getStringExtra()。上一个Activity传递过来的是整型数据，在下一个Activity中取出时就应该用getIntExtra()。以此类推。 返回数据给上一个Activity如何返回数据给上一个Activity呢？这里就用到了startActivityForResult()，这个方法与startActivity()一样，都可以启动另一个Activity。但不同的是通过startActivityForResult()来启动Activity，你便可以重写onActivityResult()方法来得到上一个Activity中你想得到的数据。具体看代码： 1.在FirstActivity中使用startActivityForResult()跳转到SecondActivity。这个方法接受两个参数，其中第二个参数为请求码，需要传入唯一值。12Intent intent = new Intent(FirstActivity.this, SecondActivity.class);startActivityForResult(intent, 1); 2.在SecondActivity中仍然通过putExtra()方法，将数据存到Intent中。这里调用了一个setResult()方法，这个方法很重要，专门用来返回数据给上一个活动。其中的第一个参数为结果码。1234Intent intent = new Intent();intent.putExtra(\"data_return\", \"Hello FirstActivity\");setResult(RESULT_OK, intent);finish(); 3.在FirstActivity中重写onActivityResult()方法，将从SecondActivity中传递过的数据取出来。由于可能在一个Activity中调用startActivityForResult()去启动很多不同的Activity，因此需要检查请求码requestCode，判断数据的来源。12345678910111213@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); switch (requestCode)&#123; case 1: if (requestCode==RESULT_OK)&#123; String returnData = data.getStringExtra(\"data_return\"); Log.d(\"FirstActivity\", returnData); &#125; break; default: break; &#125;&#125; ##结束一个Activity##下面来说说如何结束一个Activity。 You can shut down an activity by calling its finish() method. You can also shut down a separate activity that you previously started by calling finishActivity() 你可以调用finish()方法结束一个Activity，你也可以调用finishActivity()方法来结束之前开启的Activity。但是，一般情况下都不会这么做，因为Activity有其自己的生命周期。掌握这些生命周期的回调方法就可以轻松实现Activity从创建到销毁的整个过程。 ##Activity的生命周期##Activity类中定义了七个回调的方法，覆盖了Activity生命周期的每一个环节。 1.onCreate()当Activity被第一次创建时会调用此方法，你需要在此完成所需要的的初始化操作，加载布局或者绑定数据。 2.onStart()这个方法在Activity可见之前，也就是活动即将可见，但在onCreate()方法后调用。 3.onResume()这个方法在Activity准备好和用户进行交互时调用，此时的Activity会处于栈顶的位置，即Activity已经完全可见。 4.onPause()这个方法在系统准备去启动或者恢复另一个Activity的时候调用。在这里应该保存一些关键的数据，停止动画，或者将一些消耗CPU的资源释放掉。这个方法执行的一定要快，因为另一个Activity的onResume()方法要在这一个Activity的onPause()执行完后才会执行。 5.onStop()这个方法在完全不可见的时候调用。也就是当另一个Activity完全覆盖了当前的Activity就会调用此方法。当不是完全的覆盖时，例如是一个对话框式的Activity覆盖当前的Activity，则只会执行onPause()方法，而不会执行onStop()方法。 6.onDestroy()这个方法在Activity被销毁之前调用，之后活动状态变为销毁的状态。是Activity会接受的最后一个回调方法。它的回调是因为调用了finish()方法，或者是系统为了节省空间销毁了它。这两种场景可以用onFinishing()方法判断出来。 7.onRestart()这个方法在Activity被重新启动之前会调用。也就是在停止状态变为运行状态之前会调用。 其中onPause(),onStop(),onDestroy()这三个回调方法之后，是可以被系统杀死的，也就是回收资源。因为onPause()方法这三个中最先执行，onPause()方法是有保证在进程被杀死之前调用的。在系统内存紧急的情况下，onStop(),onDestroy()方法可能不会执行。因此，就需要你在onPause()方法中保存那些重要的数据，如：用户的输入。但在这个方法中不能做过多的操作，因为另一个Activity的onResume()方法要在这一个Activity的onPause()执行完后才会执行，如果在这里做了大量的操作，是会带来极差的用户体验的，因为用户的等待时间变长了。 以上的七个方法除去onRestart()之外，是两两相对的，从而将Activity分为三种生存期。 1.entire lifetime即完整生存期，就是Activity在onCreate()和onDestroy()方法之间所经历的过程。一般情况下，一个Activity要在onCreate()方法中完成各种出的初始化的操作，而在onDestroy()方法中完成资源的释放。 2.visible lifetime即可见生存期，就是Activity在onStart()和onStop()方法之间所经历的过程。在这一时期，Activity对于用户是可见的，并且可以与之交互。在这两个方法之间，你可以在Activity中维持你想向用户展示的资源。比如：你可已在onStart()方法中注册一个广播，来监听UI的变化，并且在onStop()方法中进行取消注册。 3. foreground lifetime即前台生存期，就是Activity在onResume()和onPause()方法之间所经历的过程。在这一过程中，Activity是位于屏幕上可见的，并且可以获得输入的焦点，也就是Activity处于运行的状态。此时，Activity是可以与用户进行交互的，我们平时接触的最多的也就是这一状态下的Activity了。同时，处于前台的Activity可能经常性的改变状态，在这两个方法中维护数据一定要是轻量级的，以避免用户的等待。 以下是官方文档给出的一张生命周期图，可以帮助我们更好的理解Activity的生命周期。 Activity的生命周期图 Activity完整的生命周期回调方法1234567891011121314151617181920212223242526272829303132public class ExampleActivity extends Activity &#123; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // The activity is being created. &#125; @Override protected void onStart()&#123; super.onStart(); // The activity is about to become visible. &#125; @Override protected void onResume()&#123; super.onResume(); // The activity has become visible (it is now \"resumed\"). &#125; @Override protected void onPause()&#123; super.onPause(); // Another activity is taking focus (this activity is about to be \"paused\"). &#125; @Override protected void onStop() &#123; super.onStop(); // The activity is no longer visible (it is now \"stopped\") &#125; @Override protected void onDestroy() &#123; super.onDestroy(); // The activity is about to be destroyed. &#125;&#125; ###保存Activity的状态###如何在Activity的状态改变后保存数据呢？ 下面官方文档给出了图告诉我们如何进行Activity状态改变后如何进行保存数据的操作。 Activity的状态保存 在一个Activity执行onPause()和onStop()方法后，Activity的状态仍然会保留。所以此时，再回到应用的前台，所有的状态就会恢复。但是，系统一旦回收内存，就有可能造成Activity被销毁了。此时，回到前台，就会重新执行onCreate()方法或者onRestart()方法，所以其中的数据也就都没有了。所以要想要这种情况之下进行重要数据的保存，就要用到onSaveInstanceState()这一回调方法了。但是，这一方法并不保证会在Activity销毁前一定执行，官方文档给出的解释是：用户可能通过Back键显式的离开你的Activity。所以，要调用onSaveInstanceState()就要在onStop()或者onPause()之前调用。 同时，官方文档还提到了一点。即使你没有实现这一方法，Android中几乎所有的组件都有默认还原数据的功能。但前提是你给了这个组件一个独一无二的id，即android:id。如果你不想使用这个功能，可以显式的关闭它，通过 设置android:saveEnabled属性为 “false”，或者调用setSaveEnabled()方法。 onSaveInstanceState()这一方法在Activity被销毁之前调用，这个方法携带一个Bundle类型的参数，并且是以键值对方式保存数据的，如： putString()和[putInt()。 下面看一下具体的实现： 1.在MainActivity中调用onSaveInstanceState(),进行数据的保存。123456@Overrideprotected void onSaveInstanceState(Bundle outState) &#123; super.onSaveInstanceState(outState); String tempData=\"something you just typed \"; outState.putString(\"data\",tempData);&#125; 2.如何进行数据的恢复呢？其实onCreate()方法带有一个Bundle类型的参数，这个方法一般为null，但是Activity被系统回收之前有通过onSaveInstanceState()保存数据的话，这个参数就会带有之前保存的所有数据。当然，你也可以通过onRestoreInstanceState()方法来取回数据，它同样也携带了一个Bundle类型的参数。1234567@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); if (savedInstanceState != null) &#123; String data = savedInstanceState.getString(\"data\"); Log.d(\"MainActivity\", data);&#125;&#125; 官方文档还给出一点检验Activity的还原能力的方法，就是旋转手机屏幕的方向，观察保存的数据是否能够还原。其中说到这种方法很重要，因为用户会经常性的做此动作。反正我是不会经常性的旋转屏幕，它既然提到了，就了解一下吧。 ###Activity之间的协同###在官方文档的最后，提到了如何协调各个Activity之间的关系。其实也就是遵循Activity的生命周期。它还给出一个例子：在Activity A 中开启Activity B的顺序是什么？ 1.先执行Activity A的onPause()方法。2.然后Activity B 的onCreate(),onStart(),onResume()方法会接连的执行，Acitivity B此时已经获取了焦点。3.如果此时Activity A不可见了，它的onStop()方法会得到执行。 ##Activity的启动模式##在Android启动模式一共有四种，分别是standrd，singleTop，singleTask，singleInstance。可以在AndroidManifest.xml中给标签指定android:launchMode属性来选择相应的启动模式。你也可以通过Intent携带一个Flag来指定你通过startActivity()方法来启动的另一个Activity的启动模式。当然，另一个Activity也可以在AndroidManifest.xml中指定自己的启动模式。那你就会问了一个Activity出现了两种启动模式，那这个Activity执行谁的命令啊！官方文档给出的答复是，自己在AndroidManifest.xml中定义的失效，上一个Activity从Intent中携带的Flag是什么模式，这一个Activity就执行什么模式。 1.standrd这是Activity的默认启动模式，Android使用返回栈来管理Activity。在这种模式下，系统不会在意这个Activity是否在返回栈存在，每次启动都会创建该Activity的一个实例。假如在Activity A 中启动Activity A，就会一直创建实例。在栈中就是 A-A-A，一直是叠加的。所以现在想要退出Activity，就需要按三次Back键。 2.singleTop这种启动模式，在启动Activity时会判断栈顶是否已经存在了该Activity，如果存在了该Activity就不会重复的创建实例出来，而是直接复用栈顶的Activity。还是上面的例子，在栈中的样子是A，对，仅创建一次。所以，只需要按一次Back键就可以退出Activity。如果现在栈中是这样的A-B，Activity B在栈顶，我在Activity B中启动Activity A。此时栈中的情景是A-B-A。又创建了一个A的实例，因为A不在栈顶。 3.singleTask这种启动模式，在启动Activity时会判断栈中方是否已经存在了该Activity，如果栈中存在，就会直接使用该实例，并将此Activity之上的所有Activity都出栈。也就是说此时栈中只能有这一个实例。如果栈中没有实例，就会新建一个Activity。 4.singleInstance这种启动模式是这四种当中最为特殊和复杂的一种了。声明为singleInstance模式的Activity会单独存在在一个返回栈中，不管是哪一个应用程序来访问此Activity都是共用的同一个返回栈，也就解决了共享Activity实例的问题。 ##写在最后##关于Activity相关的知识讲到这里也就算是基本完成了，这其中也仍有许多的不足，也有很多的知识没能吃透。但好在，我是看着官方文档写出的这篇文章，还是有一点进步的。其中仍然还有些知识没写到这里，其中的部分知识的理解上也存在着偏差，这些就要留在以后来解决。以后，如果我对某个知识点有新的认识，仍然会更新出来。本篇关于Activity的总结到此也就结束了。","tags":[{"name":"Android","slug":"Android","permalink":"https://KevinJe.github.io/tags/Android/"},{"name":"Activity","slug":"Activity","permalink":"https://KevinJe.github.io/tags/Activity/"}]},{"title":"Hello World","date":"2017-03-10T12:45:08.000Z","path":"2017/03/10/hello-world/","text":"2016年6月的某一天，对于别人来说可能平淡无奇，但对于我而言，意义很大。这一天，我成功的在terminal中打印出了Hello World。对计算机编程感兴趣的人可能已经知道了我正在做什么。没错，向世界致敬，Hello World。世界，我来了。从这一天开始，我开始了学习Java的旅程，也是我自学Android走出的第一步。彼时，距离Android发布已经满8年了。而我，作为一个初学者，一切才刚刚开始…… 现在的时间是2016年的10月末了，这么算下来，自学的时间也有四个月到五个月了吧。在这期间，一路的跌跌撞撞，其中充满了各种的坎坷。但好在，我坚持下来了。其中的个中滋味，也许只有自己才能知道。在这过程中，我也曾无数次的质问过自己还应不应该走下去。但每当我做出一个界面或者是修复了一个在别人眼中或许都不值得一提的bug，我却感觉到了从未有过的欢乐。也许这就是兴趣吧！虽然我现在仍然是一个编程白痴，但我还是决定学习计算机。在经历了无数次的类似的经历，我也算是有了一点Android基础。当然，这也是很令我感到兴奋的。所以，我更加的坚定了自学Android的信念。 虽然是有了一些Android的基础，但是随着学习的深入，仍然会感到很多的力不从心。有些时候，我是不知道自己下一步该做些什么的。这个问题一直也是困扰了我很长时间的。毕竟我是从一个编程白痴一点一点走过来的。在学习的方法技巧上，也有许多不好的习惯，这些都是需要我以后去改变的。所以，我决定搭建一个博客来对自己所学到的知识进行总结、归纳、演绎。 其实想搭建一个自己的blog这个想法，从我开始自学Android开始就一直在我脑海中酝酿。当然，我还是最希望自己搭建一个属于自己的blog。但是我毕竟也是从一个编程白痴走过来的，我也发现搭建一个自己的博客成本还是很高的。这个愿望就留到以后来折腾吧。所以，我在简书开通了自己的博客。 其实，第三方的博客很多，而且大多数人也都在使用第三方的博客。为什么我会选择简书呢，我一向喜欢简洁的风格，而简书就是那种很简洁的风格，所以第一眼看到简书，我就爱上它了。 这里以后就是我分享自己故事的地方，不论是生活中的、或是学习过程中的故事我也都会记录在这里。毕竟人生在世，总要给自己留一点痕迹吧。还有一点，就是我不大愿意在社交网络上分享自己的故事。现在不都是流行晒这个、晒那个嘛。但我对这种东西不感兴趣，也不敏感，甚至还有一些厌恶。所以，从某种程度上来说，我好像已经脱离了这个时代。在这里写出我的故事也就算是倾诉一下自己内心的想法吧，留给自己以后来看、来回忆。 最后，我还是希望自己能够在这条路上一直走下去，不论遇到什么，都一直坚持下去。 你好，世界，我来了。 最后的最后，借用苹果教主乔布斯的一句话来表达自己此刻的想法。 You’ve got to find what you love 我已经找到了我所喜爱的，我想我早已经无路可退。 Update:上面的文字是我在2016年10月份写于简书的，几个月过去了。自己也有了一点小小的进步，所以就想以后一直坚持写博客，记录自己生活中的点点滴滴。但愿这一次可以坚持写下去，这样就又有了一个兴趣，还可以锻炼一下写作的能力。本来打算在简书长期写博客的，就在前几天心血来潮的想要搭建属于自己的博客。于是，花了小半天的时间搭建了这个博客。当然，这个博客是基于Github Pages和Hexo的。最后，在此，感谢为开源事业做出贡献的开发者们。没有你们的奉献，一切都不会这么容易，感谢。最后的最后，还是老传统，既然来到了新的世界。就自然想到了，Hello World 。","tags":[{"name":"随笔","slug":"随笔","permalink":"https://KevinJe.github.io/tags/随笔/"}]}]