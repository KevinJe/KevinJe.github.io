<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kevin Jern</title>
  <subtitle>踏破芒鞋，烟雨任平生。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://KevinJe.github.io/"/>
  <updated>2017-03-10T13:43:57.275Z</updated>
  <id>https://KevinJe.github.io/</id>
  
  <author>
    <name>Kevin Jern</name>
    <email>kevinvin1997@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android之旅2-Android四大组件之BroadcastReceiver篇</title>
    <link href="https://KevinJe.github.io/2017/03/10/Android%E4%B9%8B%E6%97%852-Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8BBroadcastReceiver%E7%AF%87/"/>
    <id>https://KevinJe.github.io/2017/03/10/Android之旅2-Android四大组件之BroadcastReceiver篇/</id>
    <published>2017-03-10T13:20:57.000Z</published>
    <updated>2017-03-10T13:43:57.275Z</updated>
    
    <content type="html"><![CDATA[<p>今天继续我们的Android之旅，上一篇写了Android四大组件之一的Activity的知识。今天，我们继续来复习Andorid四大组件之一的BroadcastReceiver。</p>
<p>何为BroadcastReceiver呢？其实从字面就可以看出了，就是广播接收者。那这个广播的作用是什么呢？其实Android中的广播机制和现实中的广播没有什么差别。想一想现实中的广播，是不是有通知消息的用途啊。同样，Android中的广播机制也与此是类似的作用。即，通过发送广播通知系统中的某些组件该干什么了。这干什么的逻辑完全在于你自己想实现什么功能。当然，既然可以发送广播，一定也是有接受广播的功能的。</p>
<p>在Android中广播有两种类型，标准广播和有序广播。</p>
<p>标准广播（<strong>Normal broadcasts</strong>，发送方式：Context.sendBroadacst()），这是一种完全异步执行的广播，广播发出后，没有确定的顺序，广播接收者通常会在同一个时刻接收到这条广播消息。这通常意味着是高效的，但也意味着，在广播发出后是无法进行截断的。</p>
<p>有序广播（<strong>Ordered broadcasts</strong>，发送方式：Context.sendOrderedBroadcast()）,这是一种同步执行的广播，广播发出后，在同一时刻，只会有一个广播接收者接收到这一条广播。每一个广播接收者都是按顺序进行执行的。所以，前一个广播接收者既可以将这条广播传递出去，也可以完全的截断广播，使下一个广播接收者无法接收到广播。可以在AndroidManifest.xml文件中<receiver>标签下设置 android:priority属性，来匹配优先级，优先级越高，就越早接收到广播。</receiver></p>
<p>在这里要分清楚一点，虽然广播也是通过Intent进行传递的。但是通过Intent发送广播的机制与通过Intent开启另一个Activity的机制是截然不同的。开启的Activity是处于前台并且可以与用户进行交互的。而发送广播是一个后台的操作，用户并不能意识到。</p>
<p>下面来看一下具体的使用方法：</p>
<p>##接收广播##<br>如何接收广播呢？想要接收广播就要用到如何注册广播，并且在注册的逻辑中添加想要监听的广播就可以了。</p>
<p>广播的注册方式有两种，是四大组件中最为特殊的一个。其余的三个组件都必须在AndroidManifest.xml文件中进行注册声明，而BroadcastReceiver既可以在AndroidManifest.xml文件中静态注册，也可以通过代码进行动态的注册。</p>
<ul>
<li>静态注册</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">receiver</span> <span class="attr">android:name</span>=<span class="string">"com.example.kevin.receiver.BootReceiver"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.BOOT_COMPLETED"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></div></pre></td></tr></table></figure>
<p>在AndroidManifest.xml中的注册BroadcastReceiver与注册Activity没有什么太大的区别，只是标签为<receiver>。android:name来指定具体的是注册的哪一个广播。在 <intent-filter>中声明具体想要接收的广播。这里接收的是手机boot加载完成，也就是监听开机这一动作。在Android中，开机时，系统就会发送android.intent.action.BOOT_COMPLETED这条广播。</intent-filter></receiver></p>
<p>然后在代码中可以像下面这样写：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">BootReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</div><div class="line">   <span class="meta">@Override</span></div><div class="line">    public void onReceive(<span class="type">Context</span> context, <span class="type">Intent</span> intent) &#123;</div><div class="line">        <span class="type">Toast</span>.makeText(context,<span class="string">"Boot加载成功"</span>, <span class="type">Toast</span>.<span class="type">LENGTH_LONG</span>).show();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>新建一个广播继承自BroadcastReceiver，然后重写其onReceive()方法，只要系统接收到了相应的广播就会执行onReceive()方法。这里只是打印了一句吐司。</p>
<ul>
<li>动态注册</li>
</ul>
<p>动态注册就要用到registerReceiver(BroadcastReceiver, IntentFilter)这一方法了。可以看到第一个参数就是一个BroadcastReceiver。第二个参数应该也是见过的，在AndroidManifest.xml文件中用来约束具体要监听哪一个广播，同样在这里也是一样的作用。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="type">IntentFilter</span> intentFilter;</div><div class="line">    <span class="keyword">private</span> <span class="type">NetworkChangeReceiver</span> networkChangeReceiver;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstanceState) &#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        intentFilter = <span class="keyword">new</span> <span class="type">IntentFilter</span>();</div><div class="line">        <span class="comment">//当网络状态改变时，系统会发出下面这条广播</span></div><div class="line">        intentFilter.addAction(<span class="string">"android.net.conn.CONNECTIVITY_CHANGE"</span>);</div><div class="line">        networkChangeReceiver = <span class="keyword">new</span> <span class="type">NetworkChangeReceiver</span>();</div><div class="line">        registerReceiver(networkChangeReceiver, intentFilter);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">NetworkChangeReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        public void onReceive(<span class="type">Context</span> context, <span class="type">Intent</span> intent) &#123;</div><div class="line">            <span class="type">Toast</span>.makeText(context, <span class="string">"网络状态改变了"</span>, <span class="type">Toast</span>.<span class="type">LENGTH_SHORT</span>).show();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> void onDestroy() &#123;</div><div class="line">        <span class="keyword">super</span>.onDestroy();</div><div class="line">        <span class="keyword">if</span> (networkChangeReceiver != <span class="literal">null</span>) &#123;</div><div class="line">            unregisterReceiver(networkChangeReceiver);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上就是动态的注册了广播接收者来监听网络状态的改变。现在可以通过手动的改变网络状态，可以发现吐司确实是可以弹出来的，这就是动态注册。最后，记得在onDestroy()中调用unregisterReceiver()方法来取消注册。</p>
<p>##发送广播##<br>既然我们已经知道了广播分为标准广播和有序广播，那么它们是如何来进行广播的发送的呢？</p>
<ul>
<li>发送标准广播</li>
</ul>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">   <span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">       <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">       Button button = (Button) findViewById(R.id.button);</div><div class="line">       button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">               Intent intent = <span class="keyword">new</span> Intent();</div><div class="line">               intent.setAction(<span class="string">"com.coustom.BroadcastReceiver"</span>);</div><div class="line">               <span class="comment">//发送标准广播</span></div><div class="line">               sendBroadcast(intent);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>这里就是点击一下按钮就发送一条com.coustom.BroadcastReceiver这样的广播了，当然既然是通过Intent进行发送广播的操作，就可以用Intent的putExtra()方法来携带一些数据。</p>
<p>下面再演示一下如何通过静态注册和动态注册来接收上面自定义的广播。<br><strong>1.静态注册</strong></p>
<ol>
<li>在清单文件中注册</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">receiver</span> <span class="attr">android:name</span>=<span class="string">".MyBroadcastReceiver"</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></div><div class="line">               <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"com.coustom.BroadcastReceiver"</span>/&gt;</span></div><div class="line">           <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></div><div class="line"> <span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></div></pre></td></tr></table></figure>
<ol>
<li>重写对应的onReceive()方法</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyBroadcastReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</div><div class="line"></div><div class="line">      <span class="meta">@Override</span></div><div class="line">      public void onReceive(<span class="type">Context</span> context, <span class="type">Intent</span> intent) &#123;</div><div class="line">          <span class="type">Toast</span>.makeText(context, <span class="string">"收到了自定义的广播"</span>, <span class="type">Toast</span>.<span class="type">LENGTH_SHORT</span>).show();</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p><strong>2.动态注册</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"> <span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstanceState) &#123;</div><div class="line">     <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">     <span class="type">IntentFilter</span> intentFilter = <span class="keyword">new</span> <span class="type">IntentFilter</span>();</div><div class="line">     intentFilter.addAction(<span class="string">"com.custom.BroadcastReceiver"</span>);</div><div class="line">     <span class="type">MyBroadcastReceiver</span> myBroadcastReceiver = <span class="keyword">new</span> <span class="type">MyBroadcastReceiver</span>();</div><div class="line">     registerReceiver(myBroadcastReceiver,intentFilter);</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="class"><span class="keyword">class</span> <span class="title">MyBroadcastReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</div><div class="line">     <span class="meta">@Override</span></div><div class="line">     public void onReceive(<span class="type">Context</span> context, <span class="type">Intent</span> intent) &#123;</div><div class="line">         <span class="type">Toast</span>.makeText(context, <span class="string">"收到了自定义的广播"</span>, <span class="type">Toast</span>.<span class="type">LENGTH_SHORT</span>).show();</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>就是通过IntentFilter的addAction()方法来监听指定的广播，然后用 registerReceiver()就可以实现动态的注册广播。</p>
<ul>
<li>发送有序广播</li>
</ul>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">  <span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">      <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">      Button button = (Button) findViewById(R.id.button);</div><div class="line">      button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">          <span class="meta">@Override</span></div><div class="line">          <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">              Intent intent = <span class="keyword">new</span> Intent();</div><div class="line">              intent.setAction(<span class="string">"com.coustom.BroadcastReceiver"</span>);</div><div class="line">              <span class="comment">//发送有序广播</span></div><div class="line">              sendOrderedBroadcast(intent,<span class="keyword">null</span>);</div><div class="line">          &#125;</div><div class="line">      &#125;);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>和标准广播最大的不同就是调用了sendOrderedBroadcast()来发送有序广播，第一个参数仍然是Intent，第二个参数与权限有关，传入null就可以了。<br>接收这广播的方法和上面的相同。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> <span class="tag">&lt;<span class="name">receiver</span> <span class="attr">android:name</span>=<span class="string">".MyBroadcastReceiver"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">intent-filter</span> <span class="attr">android:priority</span>=<span class="string">"100"</span> &gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"com.coustom.BroadcastReceiver"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></div></pre></td></tr></table></figure>
<p>只是这里多了android:priority=”100”，来设置接收广播的优先级。如果你有创建了另一个BroadcastReceiver，并且设置它的android:priority=”50”。那么，MyBroadcastReceiver就会先接收到广播。并且既然MyBroadcastReceiver可以先接收到广播，那么它就可以决定是否将广播继续传播下去。如下所示，就表示MyBroadcastReceiver调用了 abortBroadcast()，表示不想让广播继续传播。于是，其他优先级低的广播就都接受不到这条广播了。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyBroadcastReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        public void onReceive(<span class="type">Context</span> context, <span class="type">Intent</span> intent) &#123;</div><div class="line">            <span class="type">Toast</span>.makeText(context, <span class="string">"收到了自定义的广播"</span>, <span class="type">Toast</span>.<span class="type">LENGTH_SHORT</span>).show();</div><div class="line">            <span class="comment">//终止广播的传递</span></div><div class="line">            abortBroadcast();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>##本地广播##<br> 前面的广播，不论是标准的还是有序的，都面临一个问题。即：我们发出的广播，任何其他的程序都能接收到，我们也可以接收来自其他程序的广播。这样就会带来一些安全上的问题，所以Android中还提供了LocalBroadcastManager来对广播进行管理，也就是本地广播。通过LocalBroadcastManager发送的广播只能在应用程序内部传递，也只能接受程序内部发出的广播。<br>下面来看一下具体的用法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="type">LocalBroadcastManager</span> localBroadcastManager;</div><div class="line">    <span class="keyword">private</span> <span class="type">LocalBroadcastReceiver</span> localBroadcastReceiver;</div><div class="line">    <span class="keyword">private</span> <span class="type">Context</span> mContext;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstanceState) &#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        mContext = <span class="keyword">this</span>;</div><div class="line">        <span class="comment">//得到本地广播管理者</span></div><div class="line">        localBroadcastManager = <span class="type">LocalBroadcastManager</span>.getInstance(mContext);</div><div class="line">        <span class="type">Button</span> button = (<span class="type">Button</span>) findViewById(<span class="type">R</span>.id.button);</div><div class="line">        button.setOnClickListener(<span class="keyword">new</span> <span class="type">View</span>.<span class="type">OnClickListener</span>() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            public void onClick(<span class="type">View</span> v) &#123;</div><div class="line">                <span class="type">Intent</span> intent = <span class="keyword">new</span> <span class="type">Intent</span>();</div><div class="line">                intent.setAction(<span class="string">"com.coustom.LocalBroadcastReceiver"</span>);</div><div class="line">                <span class="comment">//利用本地广播管理者发送本地广播</span></div><div class="line">                localBroadcastManager.sendBroadcast(intent);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        <span class="type">IntentFilter</span> intentFilter = <span class="keyword">new</span> <span class="type">IntentFilter</span>();</div><div class="line">        intentFilter.addAction(<span class="string">"com.coustom.LocalBroadcastReceiver"</span>);</div><div class="line">        localBroadcastReceiver = <span class="keyword">new</span> <span class="type">LocalBroadcastReceiver</span>();</div><div class="line">        <span class="comment">//利用本地广播管理者注册本地广播</span></div><div class="line">        localBroadcastManager.registerReceiver(localBroadcastReceiver, intentFilter);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LocalBroadcastReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        public void onReceive(<span class="type">Context</span> context, <span class="type">Intent</span> intent) &#123;</div><div class="line">            <span class="type">Toast</span>.makeText(context, <span class="string">"收到了本地的自定义的广播"</span>, <span class="type">Toast</span>.<span class="type">LENGTH_SHORT</span>).show();</div><div class="line">            abortBroadcast();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> void onDestroy() &#123;</div><div class="line">        <span class="keyword">super</span>.onDestroy();</div><div class="line">        <span class="keyword">if</span> (localBroadcastManager != <span class="literal">null</span>) &#123;</div><div class="line">            <span class="comment">//利用本地广播管理者取消注册本地广播</span></div><div class="line">            localBroadcastManager.unregisterReceiver(localBroadcastReceiver);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到通过<br><code>localBroadcastManager = LocalBroadcastManager.getInstance(mContext);</code><br>获取到了本地广播管理者的实例。<br>之后的发送广播、注册广播、取消注册广播都是通过localBroadcastManager来进行的。这也就是本地广播与普通广播不同的地方。</p>
<p>以下是官方文档在最后给出的，我的理解还不到位，但还是写出来吧。</p>
<p>##BroadcastReceiver的生命周期##</p>
<blockquote>
<p>一个BroadcastReceiver存在的时期就是在调用onReceive()方法所持续的时间。一旦这个方法返回了，系统就会认为对象已经执行接受，不再活跃了。这对于你在onReceive()中可以执行什么有很大的影响。异步操作在这里执行是不可能的，因为你必须从这个方法中返回并且处理异步操作，但是这时BroadcastReceiver已经不再活跃，它的进程可能再异步操作完成之前被系统杀死。</p>
</blockquote>
<p>##进程的生命周期##</p>
<blockquote>
<p>一个在执行BroadcastReceiver的方法的进程（也就是在执行其onReceive()<br>方法）被考虑是一种前台的进程，它会在系统中持续的运行除非在系统内存极紧张的情况下才会考虑杀死它。一旦onReceive()这个方法返回了，BroadcastReceiver就不再活跃了。它的宿主的进程此时对于其他正在运行的组件是重要的。这里尤为重要，如果那个进程仅仅维系一个BroadcastReceiver（一个普遍的例子：对于一个应用用户可能从没或者最近没有与之交互），一旦onReceive()这个方法执行完了，系统就会考虑这个进程是空的，就会主动的杀死它。提供可用的资源给其他更重要的进程。</p>
</blockquote>
<p>官方文档最后还给出了一条建议：</p>
<blockquote>
<p>This means that for longer-running operations you will often use a Service<br> in conjunction with a BroadcastReceiver to keep the containing process active for the entire time of your operation.<br>对于长时间运行的操作，你可以将BroadcastReceiver和Service同时应用，来保证进程在整个你的操作时期都保持活跃状态。<br>这里的建议好像就类似于桌面的小部件的实现方法，就是AppWidget。</p>
</blockquote>
<p>##写在最后##<br>上面提到了Service，它也是Android四大组件的一种，关于与Service有关的知识我们以后再来复习吧。BroadcastReceiver也就先说这么多吧，其中的部分理解还是不够深刻，我们今天就到这里了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天继续我们的Android之旅，上一篇写了Android四大组件之一的Activity的知识。今天，我们继续来复习Andorid四大组件之一的BroadcastReceiver。&lt;/p&gt;
&lt;p&gt;何为BroadcastReceiver呢？其实从字面就可以看出了，就是广播接收
    
    </summary>
    
      <category term="Android基础" scheme="https://KevinJe.github.io/categories/Android%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Android" scheme="https://KevinJe.github.io/tags/Android/"/>
    
      <category term="BroadcastReceiver" scheme="https://KevinJe.github.io/tags/BroadcastReceiver/"/>
    
  </entry>
  
  <entry>
    <title>Android之旅1-Android四大组件之Activity篇</title>
    <link href="https://KevinJe.github.io/2017/03/10/Android%E4%B9%8B%E6%97%851-Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8BActivity%E7%AF%87/"/>
    <id>https://KevinJe.github.io/2017/03/10/Android之旅1-Android四大组件之Activity篇/</id>
    <published>2017-03-10T13:18:14.000Z</published>
    <updated>2017-03-10T13:34:05.240Z</updated>
    
    <content type="html"><![CDATA[<p>关于为什么要写属于自己的博客，我在前一篇文章中也提到了。主要是归纳自己这一个时期所学到的知识，帮助自己更好的理解，同时一旦忘了某一处，还可以有个地方快速的查到。我也打算在写这些博客期间，将官方文档回顾一遍。然后，还有自己的Java方面也会一起回顾一遍，毕竟自己的Java功底薄弱啊。虽然，我的英文水平很渣，但我相信我会坚持下去的。总之，写博客是一种好的习惯，希望自己可以一直坚持下去。</p>
<p>本篇作为Android的开篇，自然就会写最常见的组件Activity了。</p>
<blockquote>
<p>一.Activity的基本使用</p>
<pre><code>1. 创建Activity
2. 开启一个Activity
</code></pre><p>   二.Activity间的数据传递过程</p>
<pre><code>1. 向下一个Activity传递数据
2. 返回数据给上一个Activity
</code></pre><p>   三.Activity的生命周期</p>
<pre><code>1. Activity的生命周期的回调方法以及回调过程
2. 保存Activity的状态
</code></pre><p>   四.Activity的启动模式</p>
</blockquote>
<p>什么是Activity，你可以翻译成<code>活动</code>，但我总觉得这么翻译有些不妥，还是不能翻译出官方的味道。有的翻译成<code>视图</code>，这种感觉还会好一些。<br>那么还是让我们看一下官方文档关于Activity的描述：</p>
<ul>
<li>#####Activity#####</li>
</ul>
<blockquote>
<p>An Activity is an application component that provides a screen with which users can interact in order to do something, such as dial the phone, take a photo, send an email, or view a map. Each activity is given a window in which to draw its user interface. The window typically fills the screen, but may be smaller than the screen and float on top of other windows.</p>
</blockquote>
<p>一个Activity是一个应用组件，它提供了一块屏幕，方便与用户之间进行某些交互。像，打电话，拍照，发送邮件，或者是浏览地图。每一个Activity被给予一块窗口，去绘制它自己的用户界面。这个窗口可以填满整个屏幕，但是也可以是比屏幕更小或者悬浮在其他窗口之上。<br>上面的官方文档的介绍已经很清楚明了了，下面看一下如何使用Activity。</p>
<ul>
<li>##创建Activity##<blockquote>
<p>To create an activity, you must create a subclass of Activity(or an existing subclass of it). In your subclass, you need to implement callback methods that the system calls when the activity transitions between various states of its lifecycle, such as when the activity is being created, stopped, resumed, or destroyed.</p>
</blockquote>
</li>
</ul>
<p>首先要新建一个Activity。并且继承Activity，实现其中需要的回调方法，其中最重要的两个回调方法是<em>onCreate()</em>和<em>onPause()</em>。</p>
<blockquote>
<p><strong>onCreate()</strong><br>You must implement this method. The system calls this when creating your activity. Within your implementation, you should initialize the essential components of your activity. Most importantly, this is where you must callsetContentView() to define the layout for the activity’s user interface.</p>
</blockquote>
<p>onCretate()是一个必须要实现的方法，系统在创建你的Activity时回调这个方法。在这里你可以初始化你的Activity所必需的组件。最重要的是，你需要调用setContentView()方法，来规范用户交互界面。</p>
<blockquote>
<p><strong>onPause()</strong><br>The system calls this method as the first indication that the user is leaving your activity (though it does not always mean the activity is being destroyed). This is usually where you should commit any changes that should be persisted beyond the current user session (because the user might not come back).</p>
</blockquote>
<p>onPause()是在用户首次离开你的Activity时调用的。所以在这个方法中，你应该保留用户的数据，给用户一个好的交互体验。</p>
<ul>
<li><p>###实现UI界面###<br>完成用户界面的绘制，通常最常用的方式就是在一个xml文件中定义好Activity所需要的布局，然后在Activity的onCreate()方法中使用setContentView()方法就可以让一个布局与Activity关联起来。</p>
</li>
<li><p>###在清单文件中进行声明###<br>每一个Activity都应该在manifest文件中定义，也就是只有在这个清单文件中有过定义，系统才会识别出你是一个Activity。下面是具体需要在什么地方定义的结点。<activity android:name=".ExampleActivity">。这句话就声明ExampleActivity是一个Activity，前面的点.代表省略的包名。</activity></p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">...</span> &gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">application</span> <span class="attr">...</span> &gt;</span> </div><div class="line">         <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".ExampleActivity"</span> /&gt;</span>  </div><div class="line">         ...</div><div class="line">    <span class="tag">&lt;/<span class="name">application</span> <span class="attr">...</span> &gt;</span> </div><div class="line">         ...</div><div class="line"><span class="tag">&lt;/<span class="name">manifest</span> &gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>####使用 intent filters####<br>使用下面的intent-filter声明一个当前的Activity是一个主活动，当启动应用时首先加载的页面就是当前这个Activity。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".ExampleActivity"</span> <span class="attr">android:icon</span>=<span class="string">"@drawable/app_icon"</span>&gt;</span> </div><div class="line">      <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span>  </div><div class="line">            <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span>   </div><div class="line">            <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></div></pre></td></tr></table></figure>
<p>总结一下如何使用Activity：</p>
<blockquote>
<ol>
<li>新建一个Activity并且继承Activity。</li>
<li>实现其中想实现的回调方法。共有七种回调方法，分别是：onCreate()、onRestart()、onStart() 、onResume()、onPause()、onStop()、onDestory()。</li>
<li>使用setContentView()方法将你的布局与Activity之间进行绑定。而布局一般都是以xml文件的形式进行定义的。这里也就涉及到了Android中的控件。</li>
<li>在manifest文件中进行注册，Android四大组件都必须在清单文件中进行注册，同时BroadcastReceiver也支持动态注册。</li>
</ol>
</blockquote>
<ul>
<li>##开启一个Activity##<br>上面讲到了如何使用Activity，但是仅仅有一个Activity是不是也太单调了。而我们现在市面上的应用都是有好多个Activity所组成。所以这里就要用到Activity之间的跳转。而Activity之间的跳转就要用到上面提到过的Intent了。</li>
</ul>
<p>官方文档中关于Intent的解释为：</p>
<blockquote>
<p>You can start another activity by calling startActivity(), passing it an Intent that describes the activity you want to start. The intent specifies either the exact activity you want to start or describes the type of action you want to perform (and the system selects the appropriate activity for you, which can even be from a different application). An intent can also carry small amounts of data to be used by the activity that is started.</p>
</blockquote>
<p>你可以启动一个其他的activity通过调用, 并传递一个Intent，它用于描述Activity。 intent指定了你想要启动的Activity,或者指定了你想展现的动作（系统帮你选择合适的Activity，它可能来自于其他的程序）。 intent也可以携带比较小量的数据，用于启动Activity。</p>
<p>从上面可以看出Intent分为两种类型，即显式Intent和隐式Intent。</p>
<p><strong>显式Intent</strong>：在你自己的应用中，你经常会简单地启动一个已知的Activity, 通过创建一个明确的intent。这个intent指定了Activity的类名。如下为启动一个名为SignInActivity的Activity：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">Intent</span> <span class="keyword">intent</span> = new <span class="keyword">Intent</span>(this, SignInActivity.<span class="keyword">class</span>);</div><div class="line">startActivity(<span class="keyword">intent</span>);</div></pre></td></tr></table></figure>
<p><strong>隐式Intent</strong>：当你的应用中没有相应的功能时，你就可以通过隐式Intent来调用系统的或者是设备上其他的应用来完成相应的功能。类似的如：发送邮件，发送短信，拨打电话。如下为调用手机中具有浏览网页功能的应用访问一个网页：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">Intent</span> <span class="keyword">intent</span> = new <span class="keyword">Intent</span>(<span class="keyword">Intent</span>.ACTION_VIEW);</div><div class="line"><span class="keyword">intent</span>.setData(Uri.parse(<span class="string">"http://www.google.com"</span>));</div><div class="line">startActivity(<span class="keyword">intent</span>);</div></pre></td></tr></table></figure>
<p>这就是隐式Intent最有价值的地方，你可以创建一个Intent来描述你想要做什么，系统会为你从其他的应用中选择合适的Activity来处理。</p>
<ul>
<li>###Activity间进行数据传递###<br><strong>向下一个Activity传递数据</strong><br>Intent中提供了的一系列的putExtra()方法的重载，可以把我们想要传递的数据暂存在Intent中，启动另外一个Activity后，再从Intent中取出数据就可以了。</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://upload-images.jianshu.io/upload_images/1602023-56c281213deac1fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Intent一系列的putExtra()方法" title="">
                </div>
                <div class="image-caption">Intent一系列的putExtra()方法</div>
            </figure>
<p>比如在FirstActivity中将一个字符串传递到SecondActivity中，可以如下操作：</p>
<p>1.在FirstActivity中将数据保存在Intent中。<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">String <span class="keyword">data</span>=<span class="string">"Hello SecondActivity"</span>;</div><div class="line"><span class="keyword">Intent</span> <span class="keyword">intent</span> = new <span class="keyword">Intent</span>(FirstActivity.this,SecondActivity.<span class="keyword">class</span>);</div><div class="line"><span class="keyword">intent</span>.putExtra(<span class="string">"extra_data"</span>,<span class="keyword">data</span>);</div><div class="line">startActivity(<span class="keyword">intent</span>);</div></pre></td></tr></table></figure></p>
<p>2.在SecondActivity中取出Intent中的数据，getIntent()方法。<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">Intent</span> <span class="keyword">intent</span> = getIntent();</div><div class="line">String <span class="keyword">data</span> = <span class="keyword">intent</span>.getStringExtra(<span class="string">"extra_data"</span>);</div><div class="line"><span class="built_in">Log</span>.d(<span class="string">"SecondActivity"</span>, <span class="keyword">data</span>);</div></pre></td></tr></table></figure></p>
<ul>
<li>如果在上一个Activity传递过来的是字符串，在下一个Activity中取出时就应该用getStringExtra()。上一个Activity传递过来的是整型数据，在下一个Activity中取出时就应该用getIntExtra()。以此类推。</li>
</ul>
<p><strong>返回数据给上一个Activity</strong><br>如何返回数据给上一个Activity呢？这里就用到了startActivityForResult()，这个方法与startActivity()一样，都可以启动另一个Activity。但不同的是通过startActivityForResult()来启动Activity，你便可以重写onActivityResult()方法来得到上一个Activity中你想得到的数据。具体看代码：</p>
<p>1.在FirstActivity中使用startActivityForResult()跳转到SecondActivity。这个方法接受两个参数，其中第二个参数为请求码，需要传入唯一值。<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">Intent</span> <span class="keyword">intent</span> = new <span class="keyword">Intent</span>(FirstActivity.this, SecondActivity.<span class="keyword">class</span>);</div><div class="line">startActivityForResult(<span class="keyword">intent</span>, <span class="number">1</span>);</div></pre></td></tr></table></figure></p>
<p>2.在SecondActivity中仍然通过putExtra()方法，将数据存到Intent中。这里调用了一个setResult()方法，这个方法很重要，专门用来返回数据给上一个活动。其中的第一个参数为结果码。<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Intent intent = new Intent()<span class="comment">;</span></div><div class="line">intent.putExtra(<span class="string">"data_return"</span>, <span class="string">"Hello FirstActivity"</span>)<span class="comment">;</span></div><div class="line">setResult(RESULT_OK, intent)<span class="comment">;</span></div><div class="line">finish()<span class="comment">;</span></div></pre></td></tr></table></figure></p>
<p>3.在FirstActivity中重写onActivityResult()方法，将从SecondActivity中传递过的数据取出来。由于可能在一个Activity中调用startActivityForResult()去启动很多不同的Activity，因此需要检查请求码requestCode，判断数据的来源。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Overrideprotected</span> <span class="function"><span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;  </div><div class="line"> <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, data);   </div><div class="line"> <span class="keyword">switch</span> (requestCode)&#123;    </div><div class="line">    <span class="keyword">case</span> <span class="number">1</span>:         </div><div class="line">         <span class="keyword">if</span> (requestCode==RESULT_OK)&#123;      </div><div class="line">            String returnData = data.getStringExtra(<span class="string">"data_return"</span>);                </div><div class="line">            Log.d(<span class="string">"FirstActivity"</span>, returnData);   </div><div class="line">         &#125;         </div><div class="line">         <span class="keyword">break</span>;     </div><div class="line">    <span class="keyword">default</span>:         </div><div class="line">         <span class="keyword">break</span>;  </div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>##结束一个Activity##<br>下面来说说如何结束一个Activity。</p>
<blockquote>
<p>You can shut down an activity by calling its finish() method. You can also shut down a separate activity that you previously started by calling finishActivity()</p>
</blockquote>
<p>你可以调用finish()方法结束一个Activity，你也可以调用finishActivity()方法来结束之前开启的Activity。但是，一般情况下都不会这么做，因为Activity有其自己的生命周期。掌握这些生命周期的回调方法就可以轻松实现Activity从创建到销毁的整个过程。</p>
<p>##Activity的生命周期##<br>Activity类中定义了七个回调的方法，覆盖了Activity生命周期的每一个环节。</p>
<p>1.onCreate()<br>当Activity被第一次创建时会调用此方法，你需要在此完成所需要的的初始化操作，加载布局或者绑定数据。</p>
<p>2.onStart()<br>这个方法在Activity可见之前，也就是活动即将可见，但在onCreate()方法后调用。</p>
<p>3.onResume()<br>这个方法在Activity准备好和用户进行交互时调用，此时的Activity会处于栈顶的位置，即Activity已经完全可见。</p>
<p>4.onPause()<br>这个方法在系统准备去启动或者恢复另一个Activity的时候调用。在这里应该保存一些关键的数据，停止动画，或者将一些消耗CPU的资源释放掉。这个方法执行的一定要快，因为另一个Activity的onResume()方法要在这一个Activity的onPause()执行完后才会执行。</p>
<p>5.onStop()<br>这个方法在完全不可见的时候调用。也就是当另一个Activity完全覆盖了当前的Activity就会调用此方法。当不是完全的覆盖时，例如是一个对话框式的Activity覆盖当前的Activity，则只会执行onPause()方法，而不会执行onStop()方法。</p>
<p>6.onDestroy()<br>这个方法在Activity被销毁之前调用，之后活动状态变为销毁的状态。是Activity会接受的最后一个回调方法。它的回调是因为调用了finish()方法，或者是系统为了节省空间销毁了它。这两种场景可以用onFinishing()方法判断出来。</p>
<p>7.onRestart()<br>这个方法在Activity被重新启动之前会调用。也就是在停止状态变为运行状态之前会调用。</p>
<p><em>其中onPause(),onStop(),onDestroy()这三个回调方法之后，是可以被系统杀死的，也就是回收资源。因为onPause()方法这三个中最先执行，onPause()方法是有保证在进程被杀死之前调用的。在系统内存紧急的情况下，onStop(),onDestroy()方法可能不会执行。因此，就需要你在onPause()方法中保存那些重要的数据，如：用户的输入。但在这个方法中不能做过多的操作，因为另一个Activity的onResume()方法要在这一个Activity的onPause()执行完后才会执行，如果在这里做了大量的操作，是会带来极差的用户体验的，因为用户的等待时间变长了。</em></p>
<p>以上的七个方法除去onRestart()之外，是两两相对的，从而将Activity分为三种生存期。</p>
<p> <strong>1.entire lifetime</strong><br>即完整生存期，就是Activity在onCreate()和onDestroy()方法之间所经历的过程。一般情况下，一个Activity要在onCreate()方法中完成各种出的初始化的操作，而在onDestroy()方法中完成资源的释放。</p>
<p><strong>2.visible lifetime</strong><br>即可见生存期，就是Activity在onStart()和onStop()方法之间所经历的过程。在这一时期，Activity对于用户是可见的，并且可以与之交互。在这两个方法之间，你可以在Activity中维持你想向用户展示的资源。比如：你可已在onStart()方法中注册一个广播，来监听UI的变化，并且在onStop()方法中进行取消注册。</p>
<p><strong>3. foreground lifetime</strong><br>即前台生存期，就是Activity在onResume()和onPause()方法之间所经历的过程。在这一过程中，Activity是位于屏幕上可见的，并且可以获得输入的焦点，也就是Activity处于运行的状态。此时，Activity是可以与用户进行交互的，我们平时接触的最多的也就是这一状态下的Activity了。同时，处于前台的Activity可能经常性的改变状态，在这两个方法中维护数据一定要是轻量级的，以避免用户的等待。</p>
<p>以下是官方文档给出的一张生命周期图，可以帮助我们更好的理解Activity的生命周期。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://upload-images.jianshu.io/upload_images/1602023-0ea517c41200bea6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Activity的生命周期图" title="">
                </div>
                <div class="image-caption">Activity的生命周期图</div>
            </figure>
<p><strong>Activity完整的生命周期回调方法</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123; </div><div class="line">    <span class="meta">@Override</span>    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;     </div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);  </div><div class="line">       <span class="comment">// The activity is being created.   </span></div><div class="line"> &#125;  </div><div class="line">     <span class="meta">@Override</span>   </div><div class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span></span>&#123;       </div><div class="line">         <span class="keyword">super</span>.onStart();     </div><div class="line">        <span class="comment">// The activity is about to become visible.  </span></div><div class="line">  &#125;    </div><div class="line">     <span class="meta">@Override</span>   </div><div class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span></span>&#123;  </div><div class="line">         <span class="keyword">super</span>.onResume();    </div><div class="line">        <span class="comment">// The activity has become visible (it is now "resumed").   </span></div><div class="line"> &#125;    </div><div class="line">     <span class="meta">@Override</span> </div><div class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span></span>&#123;       </div><div class="line">         <span class="keyword">super</span>.onPause();       </div><div class="line">        <span class="comment">// Another activity is taking focus (this activity is about to be "paused"). </span></div><div class="line">   &#125;   </div><div class="line">     <span class="meta">@Override</span>  </div><div class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;   </div><div class="line">         <span class="keyword">super</span>.onStop();     </div><div class="line">        <span class="comment">// The activity is no longer visible (it is now "stopped")   </span></div><div class="line"> &#125;  </div><div class="line">     <span class="meta">@Override</span>    </div><div class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;   </div><div class="line">        <span class="keyword">super</span>.onDestroy();     </div><div class="line">       <span class="comment">// The activity is about to be destroyed.   </span></div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>###保存Activity的状态###<br>如何在Activity的状态改变后保存数据呢？</p>
<p>下面官方文档给出了图告诉我们如何进行Activity状态改变后如何进行保存数据的操作。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://upload-images.jianshu.io/upload_images/1602023-c67d7cea9c53e267.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Activity的状态保存" title="">
                </div>
                <div class="image-caption">Activity的状态保存</div>
            </figure>
<p>在一个Activity执行onPause()和onStop()方法后，Activity的状态仍然会保留。所以此时，再回到应用的前台，所有的状态就会恢复。但是，系统一旦回收内存，就有可能造成Activity被销毁了。此时，回到前台，就会重新执行onCreate()方法或者onRestart()方法，所以其中的数据也就都没有了。所以要想要这种情况之下进行重要数据的保存，就要用到onSaveInstanceState()这一回调方法了。但是，这一方法并不保证会在Activity销毁前一定执行，官方文档给出的解释是：用户可能通过Back键显式的离开你的Activity。所以，要调用onSaveInstanceState()就要在onStop()或者onPause()之前调用。</p>
<p>同时，官方文档还提到了一点。即使你没有实现这一方法，Android中几乎所有的组件都有默认还原数据的功能。但前提是你给了这个组件一个独一无二的id，即android:id。如果你不想使用这个功能，可以显式的关闭它，通过 设置android:saveEnabled属性为 “false”，或者调用setSaveEnabled()方法。</p>
<p>onSaveInstanceState()这一方法在Activity被销毁之前调用，这个方法携带一个Bundle类型的参数，并且是以键值对方式保存数据的，如： putString()和[putInt()。</p>
<p>下面看一下具体的实现：</p>
<p>1.在MainActivity中调用onSaveInstanceState(),进行数据的保存。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle outState)</span> </span>&#123; </div><div class="line">   <span class="keyword">super</span>.onSaveInstanceState(outState);   </div><div class="line">   String tempData=<span class="string">"something you  just typed "</span>;    </div><div class="line">   outState.putString(<span class="string">"data"</span>,tempData);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2.如何进行数据的恢复呢？其实onCreate()方法带有一个Bundle类型的参数，这个方法一般为null，但是Activity被系统回收之前有通过onSaveInstanceState()保存数据的话，这个参数就会带有之前保存的所有数据。当然，你也可以通过onRestoreInstanceState()方法来取回数据，它同样也携带了一个Bundle类型的参数。<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line"><span class="keyword">protected</span> <span class="literal">void</span> onCreate(Bundle savedInstanceState) &#123;        </div><div class="line">    super.onCreate(savedInstanceState);</div><div class="line">    <span class="keyword">if</span> (savedInstanceState != <span class="built_in">null</span>) &#123;  </div><div class="line">        <span class="built_in">String</span> <span class="built_in">data</span> =  savedInstanceState.getString(<span class="string">"data"</span>);  </div><div class="line">        <span class="keyword">Log</span>.d(<span class="string">"MainActivity"</span>, <span class="built_in">data</span>);&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><em>官方文档还给出一点检验Activity的还原能力的方法，就是旋转手机屏幕的方向，观察保存的数据是否能够还原。其中说到这种方法很重要，因为用户会经常性的做此动作。反正我是不会经常性的旋转屏幕，它既然提到了，就了解一下吧。</em></p>
<p>###Activity之间的协同###<br>在官方文档的最后，提到了如何协调各个Activity之间的关系。其实也就是遵循Activity的生命周期。它还给出一个例子：在Activity A 中开启Activity B的顺序是什么？</p>
<p>1.先执行Activity A的onPause()方法。<br>2.然后Activity B 的onCreate(),onStart(),onResume()方法会接连的执行，Acitivity B此时已经获取了焦点。<br>3.如果此时Activity A不可见了，它的onStop()方法会得到执行。</p>
<p>##Activity的启动模式##<br>在Android启动模式一共有四种，分别是standrd，singleTop，singleTask，singleInstance。可以在AndroidManifest.xml中给<activity>标签指定android:launchMode属性来选择相应的启动模式。你也可以通过Intent携带一个Flag来指定你通过startActivity()方法来启动的另一个Activity的启动模式。当然，另一个Activity也可以在AndroidManifest.xml中指定自己的启动模式。那你就会问了一个Activity出现了两种启动模式，那这个Activity执行谁的命令啊！官方文档给出的答复是，自己在AndroidManifest.xml中定义的失效，上一个Activity从Intent中携带的Flag是什么模式，这一个Activity就执行什么模式。</activity></p>
<p><strong>1.standrd</strong><br>这是Activity的默认启动模式，Android使用返回栈来管理Activity。在这种模式下，系统不会在意这个Activity是否在返回栈存在，每次启动都会创建该Activity的一个实例。假如在Activity A 中启动Activity A，就会一直创建实例。在栈中就是 A-A-A，一直是叠加的。所以现在想要退出Activity，就需要按三次Back键。</p>
<p><strong>2.singleTop</strong><br>这种启动模式，在启动Activity时会判断栈顶是否已经存在了该Activity，如果存在了该Activity就不会重复的创建实例出来，而是直接复用栈顶的Activity。还是上面的例子，在栈中的样子是A，对，仅创建一次。所以，只需要按一次Back键就可以退出Activity。如果现在栈中是这样的A-B，Activity B在栈顶，我在Activity B中启动Activity A。此时栈中的情景是A-B-A。又创建了一个A的实例，因为A不在栈顶。</p>
<p><strong>3.singleTask</strong><br>这种启动模式，在启动Activity时会判断栈中方是否已经存在了该Activity，如果栈中存在，就会直接使用该实例，并将此Activity之上的所有Activity都出栈。也就是说此时栈中只能有这一个实例。如果栈中没有实例，就会新建一个Activity。</p>
<p><strong>4.singleInstance</strong><br>这种启动模式是这四种当中最为特殊和复杂的一种了。声明为singleInstance模式的Activity会单独存在在一个返回栈中，不管是哪一个应用程序来访问此Activity都是共用的同一个返回栈，也就解决了共享Activity实例的问题。</p>
<p>##写在最后##<br>关于Activity相关的知识讲到这里也就算是基本完成了，这其中也仍有许多的不足，也有很多的知识没能吃透。但好在，我是看着官方文档写出的这篇文章，还是有一点进步的。其中仍然还有些知识没写到这里，其中的部分知识的理解上也存在着偏差，这些就要留在以后来解决。以后，如果我对某个知识点有新的认识，仍然会更新出来。本篇关于Activity的总结到此也就结束了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于为什么要写属于自己的博客，我在前一篇文章中也提到了。主要是归纳自己这一个时期所学到的知识，帮助自己更好的理解，同时一旦忘了某一处，还可以有个地方快速的查到。我也打算在写这些博客期间，将官方文档回顾一遍。然后，还有自己的Java方面也会一起回顾一遍，毕竟自己的Java功底
    
    </summary>
    
      <category term="Android基础" scheme="https://KevinJe.github.io/categories/Android%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Android" scheme="https://KevinJe.github.io/tags/Android/"/>
    
      <category term="Activity" scheme="https://KevinJe.github.io/tags/Activity/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://KevinJe.github.io/2017/03/10/hello-world/"/>
    <id>https://KevinJe.github.io/2017/03/10/hello-world/</id>
    <published>2017-03-10T12:45:08.000Z</published>
    <updated>2017-03-10T15:34:55.566Z</updated>
    
    <content type="html"><![CDATA[<script type="text/javascript" src="http://www.xiami.com/widget/player-single?uid=0&sid=2071495&mode=js"></script>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://upload-images.jianshu.io/upload_images/1602023-8bfbf95bb96b95cd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/320" alt="诗与远方" title="">
                </div>
                <div class="image-caption">诗与远方</div>
            </figure>
<p>2016年6月的某一天，对于别人来说可能平淡无奇，但对于我而言，意义很大。这一天，我成功的在terminal中打印出了<code>Hello World</code>。对计算机编程感兴趣的人可能已经知道了我正在做什么。没错，向世界致敬，<code>Hello World</code>。世界，我来了。从这一天开始，我开始了学习Java的旅程，也是我自学Android走出的第一步。彼时，距离Android发布已经满8年了。而我，作为一个初学者，一切才刚刚开始……</p>
<p>现在的时间是2016年的10月末了，这么算下来，自学的时间也有四个月到五个月了吧。在这期间，一路的跌跌撞撞，其中充满了各种的坎坷。但好在，我坚持下来了。其中的个中滋味，也许只有自己才能知道。在这过程中，我也曾无数次的质问过自己还应不应该走下去。但每当我做出一个界面或者是修复了一个在别人眼中或许都不值得一提的bug，我却感觉到了从未有过的欢乐。也许这就是兴趣吧！虽然我现在仍然是一个编程白痴，但我还是决定学习计算机。在经历了无数次的类似的经历，我也算是有了一点Android基础。当然，这也是很令我感到兴奋的。所以，我更加的坚定了自学Android的信念。</p>
<p>虽然是有了一些Android的基础，但是随着学习的深入，仍然会感到很多的力不从心。有些时候，我是不知道自己下一步该做些什么的。这个问题一直也是困扰了我很长时间的。毕竟我是从一个编程白痴一点一点走过来的。在学习的方法技巧上，也有许多不好的习惯，这些都是需要我以后去改变的。所以，我决定搭建一个博客来对自己所学到的知识进行总结、归纳、演绎。</p>
<p>其实想搭建一个自己的blog这个想法，从我开始自学Android开始就一直在我脑海中酝酿。当然，我还是最希望自己搭建一个属于自己的blog。但是我毕竟也是从一个编程白痴走过来的，我也发现搭建一个自己的博客成本还是很高的。这个愿望就留到以后来折腾吧。所以，我在简书开通了自己的博客。</p>
<p>其实，第三方的博客很多，而且大多数人也都在使用第三方的博客。为什么我会选择简书呢，我一向喜欢简洁的风格，而简书就是那种很简洁的风格，所以第一眼看到简书，我就爱上它了。</p>
<p>这里以后就是我分享自己故事的地方，不论是生活中的、或是学习过程中的故事我也都会记录在这里。毕竟人生在世，总要给自己留一点痕迹吧。还有一点，就是我不大愿意在社交网络上分享自己的故事。现在不都是流行晒这个、晒那个嘛。但我对这种东西不感兴趣，也不敏感，甚至还有一些厌恶。所以，从某种程度上来说，我好像已经脱离了这个时代。在这里写出我的故事也就算是倾诉一下自己内心的想法吧，留给自己以后来看、来回忆。</p>
<p>最后，我还是希望自己能够在这条路上一直走下去，不论遇到什么，都一直坚持下去。</p>
<p><em>你好，世界，我来了。</em></p>
<p>最后的最后，借用苹果教主乔布斯的一句话来表达自己此刻的想法。</p>
<blockquote>
<p>You’ve got to find what you love</p>
</blockquote>
<hr>
<p><strong>我已经找到了我所喜爱的，我想我早已经无路可退。</strong></p>
<hr>
<p>Update:上面的文字是我在2016年10月份写于简书的，几个月过去了。自己也有了一点小小的进步，所以就想以后一直坚持写博客，记录自己生活中的点点滴滴。但愿这一次可以坚持写下去，这样就又有了一个兴趣，还可以锻炼一下写作的能力。本来打算在简书长期写博客的，就在前几天心血来潮的想要搭建属于自己的博客。于是，花了小半天的时间搭建了这个博客。当然，这个博客是基于Github Pages和Hexo的。最后，在此，感谢为开源事业做出贡献的开发者们。没有你们的奉献，一切都不会这么容易，感谢。最后的最后，还是老传统，既然来到了新的世界。就自然想到了，Hello World 。</p>
]]></content>
    
    <summary type="html">
    
      &lt;script type=&quot;text/javascript&quot; src=&quot;http://www.xiami.com/widget/player-single?uid=0&amp;sid=2071495&amp;mode=js&quot;&gt;&lt;/script&gt;

&lt;figure class=&quot;image-bub
    
    </summary>
    
      <category term="日记" scheme="https://KevinJe.github.io/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="随笔" scheme="https://KevinJe.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
